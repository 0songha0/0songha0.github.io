---
title: "타입스크립트 타입 조작 방법 / 인덱스트 액세스 타입, 맵드 타입, 조건부 타입 등"
excerpt: ""

categories:
   - web-dev
tags:
  - []

permalink: /web-dev/2025-07-30-1

toc: true
toc_sticky: true
 
date: 2025-07-30
last_modified_at: 2025-07-30
---

## 인덱스드 액세스 타입

객체, 배열, 튜플 타입에서 특정 프로퍼티 타입만 추출하는 방식입니다.

### 객체에서 프로퍼티 타입 추출
```
// 인터페이스 타입 정의 (객체 타입 정의 시 인터페이스 활용)
interface 인터페이스명 {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
  };
}

// 인터페이스 타입을 충족하는 객체 변수 생성
const 객체명: 인터페이스명 = {
  title: "제목",
  content: "본문",
  author: {
    id: 1,
    name: "하영"
  }
}

// 인덱스드 엑세스 타입으로 객체 매개변수 타입 정의
// author: { id: number; name: string; } 과 동일한 타입 정의 효과
function 함수명(author: 인터페이스명["author"]) { // 인터페이스명["author"]["id"] 형태로 중첩 사용도 가능
  console.log(`${author.id}, ${author.name}`);
}

// 함수 호출 시, 객체 내 특정 프로퍼티 타입으로 추론
함수명(객체명.author);
```
T["프로퍼티Key(=인덱스)"] 형태로 특정 프로퍼티 타입만 추출할 수 있습니다.  
프로퍼티 내 타입들이 변경되어도, 매개변수 타입 정의 코드 변경이 필요하지 않습니다.

### 배열에서 프로퍼티 타입 추출
```
// 타입 별칭 정의 (배열 타입 정의 시 타입 별칭 활용)
type 타입별칭명 = {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
  };
}[];

// 배열 타입을 충족하는 배열 변수 생성
// number, 0 등 어떤 숫자를 넣어도 배열 요소 타입 정상 추출
const 객체명: 타입별칭명[number] = {
  title: "제목",
  content: "본문",
  author: {
    id: 1,
    name: "하영"
  }
}

// 인덱스드 엑세스 타입으로 배열 매개변수 타입 정의
// author: { id: number; name: string; } 과 동일한 타입 정의 효과
function 함수명(author: 타입별칭명[number]["author"]) {
  console.log(`${author.id}, ${author.name}`);
}

// 함수 호출 시, 객체 내 특정 프로퍼티 타입으로 추론
함수명(객체명.author);
```
배열 요소 타입을 추출하고, 그 안의 특정 프로퍼티 타입만 추출하는 인덱스트 액세스 타입 예시입니다.

### 튜플에서 프로퍼티 타입 추출
```
type 튜플타입명 = [number, string, boolean];

// 튜플의 각 인덱스 요소 타입 추출
type num = 튜플타입명[0];
type str = 튜플타입명[1];
type bool = 튜플타입명[2];

// 전체 요소 유니온 타입 추출 (number | string | boolean)
type union = 튜플타입명[number];
```
인덱스드 액세스 타입으로 튜플 타입의 각 요소 타입을 추출할 수 있습니다.

---

## keyof 연산자
```
// 인터페이스 생성하여 객체 타입 정의
interface 인터페이스명 {
  name: string;
  age: number;
}

const 객체명: 인터페이스명 {
  name: "하영",
  age: 29
}

// 객체 내 특정 프로퍼티 값 반환 함수
// key 값은 인터페이스 내 프로퍼티 키 값만 허용
// key: "name" | "age" 유니온 타입으로 추론 됨
function 함수명(객체명: 인터페이스명, key: keyof 인터페이스명) {
  return 객체명[key];
}

// 함수 호출 시 출력값 : 하영
함수명(객체명, "name");
```
특정 객체 타입에서 프로퍼티 키들을 스트링 리터럴 유니온 타입으로 추출하는 연산자입니다.  
keyof 연산자는 인터페이스 등 타입에 사용 가능하고, 객체에는 사용이 불가합니다.

### keyof, typeof 연산자 활용
```
// 객체 생성
const 객체명 = {
  name: "하영",
  age: 29
}

// 객체 프로퍼티를 갖는 타입 별칭 정의
type 타입별칭명 = typeof 객체명;

// 객체 내 특정 프로퍼티 값 반환 함수
// 객체 프로퍼티를 갖는 타입에서 프로퍼티 키 유니온 타입 추출
function 함수명(객체명: 타입별칭명, key: keyof typeof 객체명) {
  return 객체명[key];
}
```
keyof, typeof 연산자로 객체 타입에서 프로퍼티 키들을 유니온 타입으로 추출할 수 있습니다.

---

## Mapped 타입 (맵드 타입)

기존 객체 타입 프로퍼티 키들을 순회하며, 새로운 객체 타입을 정의하는 문법입니다.

### Mapped 타입 정의
```
// 인터페이스 정의
interface 인터페이스명 {
  id: number;
  name: string;
  age: number;
}

// 맵드 타입 정의
type 타입별칭명 = {
  // key : "id" | "name" | "age" 프로퍼티 사용 가능
  // ? : 맵드 타입이 정의하는 모든 프로퍼티가 선택적 프로퍼티
  // value : 인터페이스[프로퍼티키]에 해당하는 타입 값 사용 가능
  [key in "id" | "name" | "age"]?: 인터페이스명[key];
  또는
  [key in keyof 인터페이스명]?: 인터페이스명[key];
}
```
맵드 타입은 인터페이스에서 사용할 수 없고, 타입 별칭으로만 정의할 수 있습니다.

---

## 템플릿 리터럴 타입
```
type 타입별칭명1 = "red" | "black";
type 타입별칭명2 = "dog" | "cat";

// 템플릿 리터럴 타입 문법으로 두 타입을 조합하여,
// 문자열 리터럴 유니온 타입 정의
// 예시 : "red - dog" | "red - cat" | "black - dog" | "black - cat"
type 템플릿리터럴타입명 = `${타입별칭명1} - ${타입별칭명2}`;
```
스트링 리터럴 타입들을 기반으로, 특정 패턴 문자열만 포함하는 유니온 타입입니다.

---

## 조건부 타입
```
type A = {
  a: number;
}

type B = {
  a: number;
  b: number;
}

// 삼항연산자로 조건부 타입 정의
// 타입B는 타입A를 포함하여 상속받으므로, number 타입으로 정의됨
type 타입별칭명 = B extends A ? number : string;
```
조건부 타입은 조건에 따라 타입을 다르게 지정할 수 있는 타입입니다.  
extends, ?, : 등을 사용하여 삼항 연산자처럼 동작합니다.

### 제네릭, 조건부 타입 활용
```
// 조건부 타입으로 제네릭 타입 정의
type 타입별칭명<T> = T extends number? string : number;

// 타입 매개변수 number 전달 시, string 타입으로 추론됨
let 변수명: 타입별칭명<number>;

// 타입 매개변수 string 전달 시, number 타입으로 추론됨
let 변수명: 타입별칭명<string>;
```
제네릭 타입 매개변수로 number가 들어오면 string 타입이 되는 조건부 타입 예시입니다.

<mark>제네릭, 조건부 타입, 함수 오버로드 시그니처 응용</mark>
```
// 함수 오버로드 시그니처 정의
// 매개변수가 string이면, 반환타입 string
// 매개변수가 없으면, 반환타입 undefined
function 함수명<T>(text: T): T extends string ? string : undefined;

// 함수 구현부
function 함수명<T>(text: any) {
  if (typeof text === "string" {
    return text.replaceAll(" ", "");
  } else {
    return undefined;
  }
}

// 함수 호출 시 매개변수 string
// 함수 반환타입 string 추론
let result = 함수명("hi hello");
retult.toUpperCase();

// 함수 호출 시 매개변수 undefined
// 함수 반환타입 undefined 추론
let result = removeSpaces(undefined);
```
함수 오버로드 시그니처 정의 시, 실제 구현부 매개변수 타입은 타입 추론에 영향을 주지 않습니다.

### 분산 조건부 타입
```
type 타입별칭명<T> = T extends number ? string : boolean;

// 유니온 분해 발생, string | boolean으로 추론됨
type Result = 타입별칭명<number | boolean>; 
```
조건부 타입에 제네릭 매개변수로 유니온 타입이 들어오면 분산이 발생합니다.

<mark>조건부 타입 분산 방지</mark>
```
type 타입별칭명<T> = [T] extends [number] ? string : boolean;

// number | boolean 유니온 타입은 number 타입이 아니므로, boolean으로 추론됨
type Result = 타입별칭명<number | boolean>; 
```
조건부 타입에서 extends 양 옆을 튜플로 감싸면, 유니온 타입 분산을 방지할 수 있습니다.

### infer 키워드
```
// 함수 타입 정의
type 타입별칭명1 = () => string;

// 조건부 타입 정의
// 제네릭 타입 T가 함수 타입이면, 함수 반환 타입을 R로 추론
type 타입별칭명2<T> = T extends () => infer R ? R : never;

// 조건부 타입 제네릭에 함수 타입 전달
type 타입별칭명3 = 타입별칭명2<타입별칭명1>;
```
infer 키워드를 사용하면, 조건부 타입 내 타입 추론이 가능합니다.

---

## 유틸리티 타입

타입스크립트에서 자주 사용되는 타입 조작 도구입니다.  
대표적으로 Partial, Required, Readonly, Pick, Omit 등이 있습니다.
