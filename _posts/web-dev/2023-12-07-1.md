---
title: "eGovframework 세션 로그인 방법 / 통합 SSO 로그인 연동 기능 개발"
excerpt: ""

categories:
  - 웹 개발
tags:
  - []

permalink: /web-dev/2023-12-07-1

toc: true
toc_sticky: true
 
date: 2023-12-07
last_modified_at: 2023-12-07
---

## eGovframework 세션 로그인 방법

### jsp에서 로그인 요청
유저가 입력한 아이디, 비밀번호가 담긴 Form을 파라미터로 ajax 호출하여 서버에 요청합니다.  
'아이디 저장' 체크박스 값이 checked이면 쿠키에 아이디를 30일 간 저장합니다.

### 서버에서 세션 로그인 처리
<mark>SSO 로그인 API 호출</mark>  
Controller에서 ajax 요청을 받고, LoginAPIUtil의 login 함수를 호출합니다.  
SSO 로그인 API URL에 get 방식으로 아이디, 비밀번호를 담고 HttpURLConnection을 통해 요청합니다.  
json 형태로 받은 결과 값을 BufferedReader로 읽고 JSONParser로 파싱해서 리턴합니다.  
Controller에서 LoginAPIUtil 리턴 값으로 정상 로그인 체크 후 공통 함수를 호출합니다.

<mark>세션 로그인 처리</mark>  
공통 함수에서 유저 테이블에서 유저 아이디로 유저 고유 ID를 조회합니다.  
조회 결과가 없으면 유저 고유 ID와 암호화 패스워드를 생성하고, 유저 테이블과 유저 권한 테이블(COMTNEMPLYRSCRTYESTBS)에 각각 insert 합니다.  
마지막으로, 유저 테이블에서 유저 고유 ID로 유저 정보들을 조회하여 LoginVO에 담아 리턴합니다.

Controller에서 LoginVO를 받아 세션에 저장합니다.
```
req.getSession().setAttribute("loginVO", loginVO);
```

ModelAndView에 유저 아이디, 유저 token, 로그인 여부를 담아 JsonView로 리턴합니다.

### jsp 콜백 함수에서 후처리
<mark>로그인 성공 시</mark>  
쿠키를 생성하고 로그인 처리하는 SSO URL에 get 방식으로 사이트명과 유저 토큰 값을 담습니다.  
IE11이면 SSO URL을 script 태그의 src 값으로 설정한 뒤 head에 append 합니다.  
IE11이 아니면 SSO URL을 Jquery getScript 함수를 통해 실행한 뒤 해당 유저 메인으로 URL을 이동합니다.

<mark>로그인 실패 시</mark>  
'아이디/비밀번호를 다시 입력해 주세요.' 팝업을 띄웁니다.

---

## 통합 SSO 로그인 연동 기능 개발

### Interceptior에서 각 화면 로그인 여부 체크
HandlerInterceptorAdapter를 상속해서 구현한 Interceptor의 preHandle 함수에서 로그인 여부와 권한을 체크하고 데이터를 담아줍니다.  

<mark>로그인 여부 체크</mark>
```
boolean isAuthenticated = EgovUserDetailsHelper.isAuthenticated();

if(isAuthenticated) {
  // 인증된 사용자 : 권한 체크 후 세션에 저장했던 LoginVO를 반환 받아 request에 담아줍니다.
  LoginVO user = (LoginVO)EgovUserDetailsHelper.getAuthenticatedUser();
  request.setAttribute("LoginUser", user);
} else {
  // 미인증 사용자 : request에 세션ID를 암호화하여 담고 ModelAndView를 통해 로그인 화면 URL으로 redirect 합니다.
  // 세션ID는 7CF30592B6FFCB7A4070A7F3BB598C19 같은 형태이며, 같은 브라우저 내에서는 다른 탭에서도 같은 세션ID를 가집니다.
  // _sessid는 현재 세션 ID에 특정 문자열과 난수를 더해서 AES256 암호화한 값입니다.
  request.setAttribute("_sessid", LoginAPIUtil.authorizeKey(request.getSession().getId()));
  ModelAndView modelAndView = new ModelAndView("redirect:/로그인페이지.do");
  throw new ModelAndViewDefiningException(modelAndView);
}
```

### jsp에서 로그인 유지 처리
<mark>유저 정보 저장</mark>
```
<c:if test="${!empty LoginUser}">
  <c:set var="login_key" value="${LoginUser.유저고유ID}"/>
  <c:set var="login_id" value="${LoginUser.유저아이디}"/>
  <c:set var="login_name" value="${LoginUser.유저명}"/>
  <c:set var="login_dateTime" value="${LoginUser.로그인시간}"/>
  <c:set var="login_userType" value="${LoginUser.유저타입}"/>
</c:if>
```
모든 페이지에 include 되는 공통 JSP 안에, 서버에서 받아온 유저 정보들을 JSTL 변수에 담아줍니다.

<mark>기존 로그인 유지 처리</mark>
```
<c:if test="${empty login_key && 로그인페이지여부 eq 'N'}">
  $.ajax({
      url: "https://SSOAPI주소:446/api/auth/Validation",
      data: { sessionData: "${_sessid}" },
      dataType: 'json',
      cache : false,
      success: function (data) {
          if (data && data.Result) {
              let Items = data.Result.Items;
              $.ajax({
                  url: "https://SSOAPI주소:446/api/auth/Authorize?Token=" + Items.Token,
                  dataType: 'text',
                  xhrFields: {
                      withCredentials: true
                  },
                  cache : false,
                  success: function (data) {
                      let reg = /_ChunjaeSSOEncData = '(.*)';/
                      let ssoData = reg.exec(data)[1];
                      if (ssoData) {
                          $.ajax({
                              url: "<c:url value="/세션로그인처리.do" />",
                              data: {
                                  ssoData: ssoData
                              },
                              type: "post",
                              success: function (res) {
                                const obj = JSON.parse(res);
                                if(obj.result==1){
                                    location.reload();
                                }
                              }
                          })
                      }
                  }
              });
          }
      }
  });
</c:if>
```
유저고유ID가 변수에 저장되어 있지 않고, 로그인 페이지가 아니면 로그인 유지 SSO API를 호출합니다.  
첫 번째 API에 _sessid를 파라미터로 넘기고, 유효성 검증을 위한 유저 토큰을 받고 SSO 쿠키도 생성 받습니다.  
두 번째 API에서 유저 토큰을 파라미터로 넘기고, 유저 ID가 암호화된 SSO 쿠키 값이 인증되면 유저 정보가 암호화된 SSO 데이터를 받을 수 있습니다.  
SSO 데이터가 있으면 신규 세션 로그인 처리 Controller URL에 파라미터로 넘기면서 ajax로 호출합니다.  
Controller에서 SSO 데이터의 유저 정보를 복호화하고 LoginVO에 담아 세션에 저장하여 로그인 처리 합니다.

---

## SSO 쿠키가 생성되지 않는 경우

타 앱에서 우리 웹으로 이동 시 로그인 유지 처리를 개발하고 있었습니다.  
SSO API에서 쿠키를 생성해주었다는데 타 사이트 URL 쿠키라 우리 사이트에서 활용할 수 없었습니다.  
그래서 컨트롤러에서 로그인 해도 되는 유저인지 체크 후 수동 로그인 화면 또는 iframe 화면으로 보내주었습니다.  
SSO API를 java, javascript에서 호출하면 쿠키가 없어서 유저 정보를 받을 수 없지만,  
iframe으로 쿠키 생성 API를 띄우고 기존 로그인 유지 처리 ajax가 있는 화면으로 보내면 정상 동작하였습니다.

<mark>모바일 쿠키 주의사항</mark>  
하지만 이 방법도 크롬 브라우저에서만 정상적으로 동작합니다.  
안드로이드:삼성 인터넷 브라우저, iOS:사파리 등 모바일 기본 브라우저에서는 도메인이 다른 Cross site 쿠키 공유가 되지 않아 로그인이 되지 않습니다.  
결국 유저 쿠키 없이 유저 토큰만 받고도 사용자 정보를 응답하는 신규 SSO API 생성을 요청하고, 두 번째 API 주소를 변경하였습니다.

### Controller 코드
```
@RequestMapping(value = "/SSO로그인.do")
  public String actionLoginTsherpaAppProfSso(@RequestParam("userkey") String userkey, HttpServletRequest request, ModelMap model, HttpServletResponse res) throws Exception {
    
    try {
      // 앱에서 보내준 암호화 userkey 복호화
      AES256Util aes256Util = new AES256Util(프로퍼티유틸.SSOAESKEY);

      String decodeString = URLDecoder.decode(userkey, StandardCharsets.UTF_8.name());
      String userkeyDecode = aes256Util.aesDecode(decodeString);

      // 원본 userkey 암호화
      String userkeyEncode = URLEncoder.encode(AES256암호화함수(userkeyDecode), "UTF-8");

      request.setAttribute("userkeyEncode", userkeyEncode);

      // 로그인 해도 되는 유저인지 체크

    } catch (Exception e) {
      // 로그인 실패 화면
      return "redirect:/cmmn/login.do";
    }

    // 로그인 쿠키 생성 페이지
    return "view/user/cmmn/appLoginCmmn";
  }
```

### AES256 암호화 함수
```
public static String AES256암호화함수(String userkeyDecode) {

  String ssoFormat = MessageFormat.format("{0}^{1}^{2}", userkeyDecode, "특정문자열", new Date().getTime());

  AES256Util aes = new AES256Util(프로퍼티유틸.SSOAESKEY);
  String ssoStr = aes.aesEncode(ssoFormat);

  return ssoStr;
}
```

### iframe 화면 코드
```
<head>
  <script type="text/javaScript" language="javascript">
	  function doLoad(){
      let loginSuccess = false;
      
      $.ajax({
        url: "https://SSOAPI주소:446/api/auth/ValidationOutStudent",
        data: { sessionData: "${userkeyEncode}" },
        dataType: 'json',
        cache : false,
        success: function (data) {
            if (data && data.Result) {
                let Items = data.Result.Items;
                
                if (data.StatusCode == "AUTH_OK") {
                  loginSuccess = true

                  // 로그인 성공 화면 (기존 로그인 유지 처리가 있는 메인 화면)
                  location.href="<c:url value='/cmmn/index.do'/>";
                }
            }
        },
        complete : function () {
          // ajax 호출 완료 후 인증이 확인되지 않으면
          if (loginSuccess == false) { 
              // 로그인 실패 화면 (수동 로그인 화면)
              location.href = "<c:url value='/cmmn/loginStu.do' />";
          }
        }
      });
    }
   </script>
</head>

<body class="main">
  <iframe src="https://SSOAPI주소:446/api/auth/ValidationOutStudent?파라미터=${값}" width="0" height="0" style="display:block" name="egloos" onload="doLoad()"></iframe>
</body>
```
iframe에서 해당 API를 호출하면 SSO 도메인에 쿠키가 정상적으로 생성됩니다.  
같은 API를 ajax에서도 호출해서 유효성을 체크하고 화면을 분기해줘야 에러가 나지 않습니다.

<mark>noscript</mark>
```
<noscript><iframe src="https://SSOAPI주소:446/api/auth/ValidationOutStudent?파라미터=${값}" height="0" width="0" style="display:none; visibility:hidden"></iframe></noscript>
```
body 아래에서 noscript 태그로 iframe을 감싸서 API 실행하는 방법도 있습니다. 이 경우, onload는 사용할 수 없습니다.
