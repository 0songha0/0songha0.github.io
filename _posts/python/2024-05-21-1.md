---
title: "프로그래머스 코딩 기초 트레이닝 Lv.0 124문제 Java 풀이 (작성중)"
excerpt: ""

categories:
  - 파이썬 / 코딩테스트
tags:
  - []

permalink: /python/2024-05-21-1

toc: true
toc_sticky: true
 
date: 2024-05-21
last_modified_at: 2024-05-21
---

## 프로그래머스 코딩 기초 트레이닝 Lv.0 124문제

<https://school.programmers.co.kr/learn/challenges/training?order=recent&page=1>{: target="_blank"}  
문자열 연산, 배열, 조건문, 반복문 등 기본적인 Java 문법을 익힐 수 있는 문제들입니다.  
정답률 높은 순으로 풀면 성취감 느끼며 기본을 다질 수 있습니다.

### 출력 문제 풀이
<mark>문자열 출력하기</mark>
```
```

<mark>a와 b 출력하기</mark>
```
```

<mark>문자열 반복해서 출력하기</mark>
```
```

<mark>대소문자 바꿔서 출력하기</mark>
```
```

<mark>특수문자 출력하기</mark>
```
```

<mark>덧셈식 출력하기</mark>
```
```

<mark>문자열 붙여서 출력하기</mark>
```
```

<mark>문자열 돌리기</mark>
```
```

<mark>홀짝 구분하기</mark>
```
```

### 연산 문제 풀이
<mark>문자열 겹쳐쓰기</mark>
```
```

<mark>문자열 섞기</mark>
```
```

<mark>문자 리스트를 문자열로 변환하기</mark>
```
```

<mark>문자열 곱하기</mark>
```
class Solution {
  public String solution(String my_string, int k) {
    return my_string.repeat(k);
  }
}
```

<mark>더 크게 합치기</mark>
```
class Solution {
  public int solution(int a, int b) {
    return Math.max(Integer.parseInt(a + "" + b), Integer.parseInt(b + "" + a));
  }
}
```

<mark>두 수의 연산값 비교하기</mark>
```
class Solution {
  public int solution(int a, int b) {
    int case1 = Integer.parseInt(String.valueOf(a) + String.valueOf(b));
    
    int case2 = 2 * a * b;
    
    return Math.max(case1, case2);
  }
}
```

<mark>n의 배수</mark>
```
class Solution {
  public int solution(int num, int n) {
    return num % n == 0 ? 1 : 0;
  }
}
```

<mark>공배수</mark>
```
class Solution {
  public int solution(int number, int n, int m) {
    int answer = 0;
    
    if (number % n == 0 && number % m == 0) {
      answer = 1;
    }
    
    return answer;
  }
}
```
아래처럼, 삼항연산자를 사용하면 더 짧게 구현할 수 있습니다.
```
class Solution {
  public int solution(int number, int n, int m) {
    return number % n == 0 && number % m == 0 ? 1 : 0;
  }
}
```

### 조건문 문제 풀이
<mark>홀짝에 따라 다른 값 반환하기</mark>
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    
    boolean isEven = false;
    
    if (n % 2 == 0) {
      isEven = true;
    }
    
    for (int i = 1; i <= n; i++) {
      if (isEven) {
        if (i % 2 == 0) {
          answer += (i * i);
        }
      } else {
        if (i % 2 == 1) {
          answer += i;
        }
      }
    }
    
    return answer;
  }
}
```
아래처럼, 홀짝 for문을 분리하면 반복 중 비교 연산을 줄일 수 있습니다.
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    
    if (n % 2 == 0) {
      for (int i = 2; i <= n; i += 2) {
        answer += i * i;
      }
    } else {
      for (int i = 1; i <= n; i += 2) {
        answer += i;
      }
    }
    
    return answer;
  }
}
```

<mark>조건 문자열</mark>
```
```

<mark>flag에 따라 다른 값 반환하기</mark>
```
class Solution {
  public int solution(int a, int b, boolean flag) {
    if (flag) {
      return a + b;
    } else {
      return a - b;
    }
  }
}
```
아래처럼 삼항연산자로 더 간단하게 구현할 수 있습니다.
```
class Solution {
  public int solution(int a, int b, boolean flag) {
    return flag ? a + b : a - b;
  }
}
```

<mark>코드 처리하기</mark>
```
```

<mark>등차수열의 특정한 항만 더하기</mark>
```
```

<mark>주사위 게임 2</mark>
```
```

<mark>원소들의 곱과 합</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int gop = 1;
    int sum = 0;

    for (int num : num_list) {
      gop *= num;
      sum += num;
    }
    
    return gop <= (sum * sum) ? 1 : 0;
  }
}
```

<mark>이어 붙인 수</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int answer = 0;
    String odd = "";
    String even = "";
    
    for (int num : num_list) {
      if (num % 2 == 1) {
        odd += String.valueOf(num);
      } else {
        even += String.valueOf(num);
      }
    }
    
    return Integer.parseInt(odd) + Integer.parseInt(even);
  }
}
```

<mark>마지막 두 원소</mark>
```
class Solution {
  public int[] solution(int[] num_list) {
    int[] answer = new int[num_list.length+1];
    
    for (int i = 0; i < num_list.length; i++) {
      answer[i] = num_list[i];
    }
    
    int last = answer[num_list.length-1];
    int last_prev = answer[num_list.length-2];
    
    if (last > last_prev) {
      answer[num_list.length] = last - last_prev;
    } else {
      answer[num_list.length] = last * 2;
    }
    
    return answer;
  }
}
```
아래처럼, 마지막 부분을 삼항 연산자로 줄일 수 있습니다.
```
class Solution {
  public int[] solution(int[] num_list) {
    int[] answer = new int[num_list.length+1];
    
    for (int i = 0; i < num_list.length; i++) {
      answer[i] = num_list[i];
    }
    
    int last = answer[num_list.length-1];
    int last_prev = answer[num_list.length-2];
    
    answer[num_list.length] = last > last_prev ? last - last_prev : last * 2;
    
    return answer;
  }
}
```

<mark>수 조작하기 1</mark>
```
class Solution {
  public int solution(int n, String control) {
    int answer = n;
    
    for (char c : control.toCharArray()) {
      if (c == 'w') {
        answer += 1;
      } else if (c == 's') {
        answer -= 1;
      } else if (c == 'd') {
        answer += 10;
      } else {
        answer -= 10;
      } 
    }
    
    return answer;
  }
}
```

<mark>수 조작하기 2</mark>
```
```

<mark>간단한 논리 연산</mark>
```
```

<mark>주사위 게임 3</mark>
```
```

<mark>배열의 원소 삭제하기</mark>
```
```

<mark>부분 문자열인지 확인하기</mark>
```
```

<mark>부분 문자열</mark>
```
```

<mark>꼬리 문자열</mark>
```
```

<mark>정수 찾기</mark>
```
```

<mark>주사위 게임 1</mark>
```
```

<mark>날짜 비교하기</mark>
```
```

<mark>커피 심부름</mark>
```
```

### 반복문 문제 풀이
<mark>수열과 구간 쿼리 3</mark>
```
```

<mark>수열과 구간 쿼리 2</mark>
```
```

<mark>수열과 구간 쿼리 4</mark>
```
```

<mark>배열 만들기 2</mark>
```
```

<mark>카운트 업</mark>
```
class Solution {
  public int[] solution(int start_num, int end_num) {
    int[] answer = new int[end_num - start_num +1];
    
    int index = 0;
    
    for (int i = start_num; i <= end_num; i++) {
      answer[index++] = i;
    }
        
    return answer;
  }
}
```
```
class Solution {
  public int[] solution(int start_num, int end_num) {
    int[] answer = new int[end_num - start_num +1];
    
    for (int i = 0; i <= end_num - start_num; i++) {
      answer[i] = i + start_num;
    }
        
    return answer;
  }
}
```

<mark>콜라츠 수열 만들기</mark>
```
```

<mark>배열 만들기 4</mark>
```
```

<mark>그림 확대</mark>
```
```

<mark>조건에 맞게 수열 변환하기 3</mark>
```
```

<mark>l로 만들기</mark>
```
```

### 문자열 문제 풀이
<mark>글자 이어 붙여 문자열 만들기</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string, int[] index_list) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = 0; i < index_list.length; i++) {
      sb.append(my_string.substring(index_list[i], index_list[i]+1));
    }
    
    return sb.toString();
  }
}
```
아래처럼 charAt으로 문자를 추출하면 더 쉽게 이어붙일 수 있습니다.
```
import java.util.*;

class Solution {
  public String solution(String my_string, int[] index_list) {
    StringBuilder sb = new StringBuilder();
    
    for (int index : index_list) {
      sb.append(my_string.charAt(index));
    }
    
    return sb.toString();
  }
}
```

<mark>9로 나눈 나머지</mark>
```
```

<mark>문자열 여러 번 뒤집기</mark>
```
```

<mark>배열 만들기 5</mark>
```
```

<mark>부분 문자열 이어 붙여 문자열 만들기</mark>
```
```

<mark>문자열의 뒤의 n글자</mark>
```
class Solution {
  public String solution(String my_string, int n) {
    return my_string.substring(my_string.length()-n);
  }
}
```

<mark>접미사 배열</mark>
```
```

<mark>접미사인지 확인하기</mark>
```
class Solution {
  public int solution(String my_string, String is_suffix) {
    int i = my_string.indexOf(is_suffix, my_string.length() - is_suffix.length());
    
    if (my_string.length() < is_suffix.length()) {
      return 0;
    }
    
    return i + is_suffix.length() == my_string.length()? 1 : 0;
  }
}
```
아래처럼, endsWith 함수를 사용하면 접미사인지 더 쉽게 확인할 수 있습니다.
```
class Solution {
  public int solution(String my_string, String is_suffix) {
    if (my_string.endsWith(is_suffix)) {
      return 1;
    }
    
    return 0;
  }
}
```

<mark>문자열의 앞의 n글자</mark>
```
class Solution {
  public String solution(String my_string, int n) {
    return my_string.substring(0, n);
  }
}
```

<mark>접두사인지 확인하기</mark>
```
class Solution {
  public int solution(String my_string, String is_prefix) {
    return my_string.indexOf(is_prefix) == 0? 1 : 0;
  }
}
```
startsWith 함수로 더 간단히 확인할 수 있습니다.
```
class Solution {
  public int solution(String my_string, String is_prefix) {
    return my_string.startsWith(is_prefix)? 1 : 0;
  }
}
```

<mark>문자열 뒤집기</mark>
```
```

<mark>세로 읽기</mark>
```
```

<mark>qr code</mark>
```
```

<mark>원하는 문자열 찾기</mark>
```
```

<mark>대문자로 바꾸기</mark>
```
```

<mark>소문자로 바꾸기</mark>
```
```

<mark>배열에서 문자열 대소문자 변환하기</mark>
```
```

<mark>A 강조하기</mark>
```
```

<mark>특정한 문자를 대문자로 바꾸기</mark>
```
```

<mark>특정 문자열로 끝나는 가장 긴 부분 문자열 찾기</mark>
```
```

<mark>문자열이 몇 번 등장하는지 세기</mark>
```
```

<mark>ad 제거하기</mark>
```
```

<mark>공백으로 구분하기 1</mark>
```
```

<mark>공백으로 구분하기 2</mark>
```
```

<mark>x 사이의 개수</mark>
```
```

<mark>문자열 잘라서 정렬하기</mark>
```
```

<mark>간단한 식 계산하기</mark>
```
```

<mark>문자열 바꿔서 찾기</mark>
```
```

<mark>rny_string</mark>
```
```

<mark>세 개의 구분자</mark>
```
```

### 배열 문제 풀이

<mark>문자 개수 세기</mark>
```
```

<mark>배열 만들기 1</mark>
```
class Solution {
  public int[] solution(int n, int k) {
    int[] answer = new int[n / k];
    
    for (int i = 1; i <= n; i++) {
      if (i % k == 0) {
        answer[i / k -1] = i;
      }
    }
    
    return answer;
  }
}
```

<mark>글자 지우기</mark>
```
```

<mark>카운트 다운</mark>
```
class Solution {
  public int[] solution(int start, int end_num) {
    int[] answer = new int[start - end_num +1];
    
    for (int i = start; i >= end_num; i--) {
      answer[start - i] = i;
    }
    
    return answer;
  }
}
```

<mark>가까운 1 찾기</mark>
```
```

<mark>리스트 자르기</mark>
```
```

<mark>첫 번째로 나오는 음수</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int answer = -1;
    
    for (int i = 0; i < num_list.length; i++) {
      if (num_list[i] < 0) {
        answer = i;
        break;
      }
    }
    
    return answer;
  }
}
```

<mark>배열 만들기 3</mark>
```
```

<mark>2의 영역</mark>
```
```

<mark>배열 조각하기</mark>
```
```

<mark>n 번째 원소부터</mark>
```
class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] answer = new int[num_list.length -n +1];
    
    for (int i = n; i <= num_list.length; i++) {
      answer[i-n] = num_list[i-1];
    }
    
    return answer;
  }
}
```
아래처럼, copyOfRange를 사용하면 배열을 쉽게 자를 수 있습니다.
```
import java.util.*;

class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] answer = Arrays.copyOfRange(num_list, n-1, num_list.length);
    
    return answer;
  }
}
```

<mark>순서 바꾸기</mark>
```
```

<mark>왼쪽 오른쪽</mark>
```
```

<mark>n번째 원소까지</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] answer = Arrays.copyOfRange(num_list, 0, n);
    return answer;
  }
}
```

<mark>n개 간격의 원소들</mark>
```
import java.util.ArrayList;

class Solution {
  public int[] solution(int[] num_list, int n) {
      
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int i = 0; i < num_list.length; i++) {
      if (i % n == 0) {
        list.add(num_list[i]);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
        
    return answer;
  }
}
```

<mark>홀수 vs 짝수</mark>
```
```

<mark>5명씩</mark>
```
```

<mark>할 일 목록</mark>
```
```

<mark>n보다 커질 때까지 더하기</mark>
```
class Solution {
  public int solution(int[] numbers, int n) {
    int answer = 0;
    
    for (int v : numbers) {
      answer += v;
      
      if (answer > n) {
        break;
      }
    }
    
    return answer;
  }
}
```

<mark>수열과 구간 쿼리 1</mark>
```
```

<mark>조건에 맞게 수열 변환하기 1</mark>
```
class Solution {
  public int[] solution(int[] arr) {
    int[] answer = {};
    
    for (int i = 0; i < arr.length; i++) {
      int v = arr[i];
      
      if (v >= 50 && v % 2 == 0) {
        arr[i] = v / 2;
      }
          
      if (v < 50 && v % 2 == 1) {
        arr[i] = v * 2;
      }
    }
    
    return arr;
  }
}
```

<mark>조건에 맞게 수열 변환하기 2</mark>
```
```

<mark>1로 만들기</mark>
```
```

<mark>길이에 따른 연산</mark>
```
```

<mark>배열의 원소만큼 추가하기</mark>
```
```

<mark>빈 배열에 추가, 삭제하기</mark>
```
```

<mark>배열 만들기 6</mark>
```
```

<mark>무작위로 K개의 수 뽑기</mark>
```
```

### 이차원 배열 문제 풀이

<mark>특별한 이차원 배열 1</mark>
```
```

<mark>정수를 나선형으로 배치하기</mark>
```
```

<mark>특별한 이차원 배열 2</mark>
```
```

<mark>정사각형으로 만들기</mark>
```
```

<mark>이차원 배열 대각선 순회하기</mark>
```
```

### 함수 문제 풀이
<mark>배열의 길이를 2의 거듭제곱으로 만들기</mark>
```
```

<mark>배열 비교하기</mark>
```
```

<mark>문자열 묶기</mark>
```
```

<mark>배열의 길이에 따라 다른 연산하기</mark>
```
```

<mark>뒤에서 5등까지</mark>
```
```

<mark>뒤에서 5등 위로</mark>
```
```

<mark>전국 대회 선발 고사</mark>
```
```

<mark>정수 부분</mark>
```
```

<mark>문자열 정수의 합</mark>
```
```

<mark>문자열을 정수로 변환하기</mark>
```
```

<mark>0 떼기</mark>
```
```

<mark>두 수의 합</mark>
```
```

<mark>문자열로 변환</mark>
```
```