---
title: "프로그래머스 코딩 기초 트레이닝 Lv.0 124문제 Java 풀이 (작성중)"
excerpt: ""

categories:
  - 파이썬 / 코딩테스트
tags:
  - []

permalink: /python/2024-05-21-1

toc: true
toc_sticky: true
 
date: 2024-05-21
last_modified_at: 2024-05-21
---

## 프로그래머스 코딩 기초 트레이닝 Lv.0 124문제

<https://school.programmers.co.kr/learn/challenges/training?order=recent&page=1>{: target="_blank"}  
문자열 연산, 배열, 조건문, 반복문 등 기본적인 Java 문법을 익힐 수 있는 문제들입니다.  
정답률 높은 순으로 풀면 성취감 느끼며 기본을 다질 수 있습니다.

### 출력 문제 풀이
<mark>문자열 출력하기</mark>
```
```

<mark>a와 b 출력하기</mark>
```
```

<mark>문자열 반복해서 출력하기</mark>
```
```

<mark>대소문자 바꿔서 출력하기</mark>
```
```

<mark>특수문자 출력하기</mark>
```
```

<mark>덧셈식 출력하기</mark>
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();

    System.out.println(a + " + " + b + " = " + (a + b));
  }
}
```
아래처럼, printf 함수로도 구현할 수 있습니다.
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();

    System.out.printf("%d + %d = %d", a, b, a+b);
  }
}
```

<mark>문자열 붙여서 출력하기</mark>
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String a = sc.next();
    String b = sc.next();
    
    System.out.println(a + b);
  }
}
```
이 문제는 아래처럼 다양한 풀이가 가능합니다.
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String a = sc.next();
    for(int i=0; i < a.length(); i++){
      System.out.println(a.charAt(i));
    }
  }
}
```
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String a = sc.next();
    for(String s : a.split("")){
      System.out.println(s);
    }
  }
}

```

<mark>문자열 돌리기</mark>
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String a = sc.next();
    
    for (char c : a.toCharArray()) {
      System.out.println(c);
    }
  }
}
```

<mark>홀짝 구분하기</mark>
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    
    if (n % 2 == 0) {
      System.out.println(n + " is even");
    } else {
      System.out.println(n + " is odd");
    }
  }
}
```

### 연산 문제 풀이
<mark>문자열 겹쳐쓰기</mark>
```
```

<mark>문자열 섞기</mark>
```
class Solution {
  public String solution(String str1, String str2) {
    String answer = "";
    
    for (int i = 0; i < str1.length(); i++) {
      answer += str1.charAt(i) + "" + str2.charAt(i);
    }
    
    return answer;
  }
}
```
아래처럼, StringBuilder를 사용하여 문자열 결합하는 것이 메모리 효율적입니다.
```
class Solution {
  public String solution(String str1, String str2) {
    char[] chars1 = str1.toCharArray();
    char[] chars2 = str2.toCharArray();

    StringBuilder sb = new StringBuilder();
    for (int i=0; i<chars1.length; i++) {
      sb.append(chars1[i]);
      sb.append(chars2[i]);
    }

    return sb.toString();
  }
}
```
StringBuilder는 java.lang 패키지에 포함되어 있어, import문 없이 사용할 수 있습니다.

<mark>문자 리스트를 문자열로 변환하기</mark>
```
class Solution {
  public String solution(String[] arr) {
    return String.join("", arr);
  }
}
```

<mark>문자열 곱하기</mark>
```
class Solution {
  public String solution(String my_string, int k) {
    return my_string.repeat(k);
  }
}
```

<mark>더 크게 합치기</mark>
```
class Solution {
  public int solution(int a, int b) {
    return Math.max(Integer.parseInt(a + "" + b), Integer.parseInt(b + "" + a));
  }
}
```

<mark>두 수의 연산값 비교하기</mark>
```
class Solution {
  public int solution(int a, int b) {
    int case1 = Integer.parseInt(String.valueOf(a) + String.valueOf(b));
    
    int case2 = 2 * a * b;
    
    return Math.max(case1, case2);
  }
}
```

<mark>n의 배수</mark>
```
class Solution {
  public int solution(int num, int n) {
    return num % n == 0 ? 1 : 0;
  }
}
```

<mark>공배수</mark>
```
class Solution {
  public int solution(int number, int n, int m) {
    int answer = 0;
    
    if (number % n == 0 && number % m == 0) {
      answer = 1;
    }
    
    return answer;
  }
}
```
아래처럼, 삼항연산자를 사용하면 더 짧게 구현할 수 있습니다.
```
class Solution {
  public int solution(int number, int n, int m) {
    return number % n == 0 && number % m == 0 ? 1 : 0;
  }
}
```

### 조건문 문제 풀이
<mark>홀짝에 따라 다른 값 반환하기</mark>
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    
    boolean isEven = false;
    
    if (n % 2 == 0) {
      isEven = true;
    }
    
    for (int i = 1; i <= n; i++) {
      if (isEven) {
        if (i % 2 == 0) {
          answer += (i * i);
        }
      } else {
        if (i % 2 == 1) {
          answer += i;
        }
      }
    }
    
    return answer;
  }
}
```
아래처럼, 홀짝 for문을 분리하면 반복 중 비교 연산을 줄일 수 있습니다.
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    
    if (n % 2 == 0) {
      for (int i = 2; i <= n; i += 2) {
        answer += i * i;
      }
    } else {
      for (int i = 1; i <= n; i += 2) {
        answer += i;
      }
    }
    
    return answer;
  }
}
```

<mark>조건 문자열</mark>
```
```

<mark>flag에 따라 다른 값 반환하기</mark>
```
class Solution {
  public int solution(int a, int b, boolean flag) {
    if (flag) {
      return a + b;
    } else {
      return a - b;
    }
  }
}
```
아래처럼 삼항연산자로 더 간단하게 구현할 수 있습니다.
```
class Solution {
  public int solution(int a, int b, boolean flag) {
    return flag ? a + b : a - b;
  }
}
```

<mark>코드 처리하기</mark>
```
```

<mark>등차수열의 특정한 항만 더하기</mark>
```
class Solution {
  public int solution(int a, int d, boolean[] included) {
    int answer = 0;
    
    for (int i = 0; i < included.length; i++) {
      if (included[i]) {
        answer += a + (i * d);
      }
    }
    
    return answer;
  }
}
```

<mark>주사위 게임 2</mark>
```
import java.util.*;

class Solution {
  public int solution(int a, int b, int c) {
    int answer = 0;
    
    Set<Integer> hashSet = new HashSet<>();
    
    hashSet.add(a);
    hashSet.add(b);
    hashSet.add(c);
    
    switch (hashSet.size()) {
      case 3:
        answer = a + b + c;
        break;
      case 2:
        answer = (a + b + c) * (a*a + b*b + c*c);
        break;
      case 1:
        answer = (a + b + c) * (a*a + b*b + c*c) * (a*a*a + b*b*b + c*c*c);
        break;
    }
    
    return answer;
  }
}
```
(int) Math.pow(a, 제곱수) 로 제곱을 구할 수 있으나, 가독성을 위해 사용하지 않았습니다.

<mark>원소들의 곱과 합</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int gop = 1;
    int sum = 0;

    for (int num : num_list) {
      gop *= num;
      sum += num;
    }
    
    return gop <= (sum * sum) ? 1 : 0;
  }
}
```

<mark>이어 붙인 수</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int answer = 0;
    String odd = "";
    String even = "";
    
    for (int num : num_list) {
      if (num % 2 == 1) {
        odd += String.valueOf(num);
      } else {
        even += String.valueOf(num);
      }
    }
    
    return Integer.parseInt(odd) + Integer.parseInt(even);
  }
}
```

<mark>마지막 두 원소</mark>
```
class Solution {
  public int[] solution(int[] num_list) {
    int[] answer = new int[num_list.length+1];
    
    for (int i = 0; i < num_list.length; i++) {
      answer[i] = num_list[i];
    }
    
    int last = answer[num_list.length-1];
    int last_prev = answer[num_list.length-2];
    
    if (last > last_prev) {
      answer[num_list.length] = last - last_prev;
    } else {
      answer[num_list.length] = last * 2;
    }
    
    return answer;
  }
}
```
아래처럼, 마지막 부분을 삼항 연산자로 줄일 수 있습니다.
```
class Solution {
  public int[] solution(int[] num_list) {
    int[] answer = new int[num_list.length+1];
    
    for (int i = 0; i < num_list.length; i++) {
      answer[i] = num_list[i];
    }
    
    int last = answer[num_list.length-1];
    int last_prev = answer[num_list.length-2];
    
    answer[num_list.length] = last > last_prev ? last - last_prev : last * 2;
    
    return answer;
  }
}
```

<mark>수 조작하기 1</mark>
```
class Solution {
  public int solution(int n, String control) {
    int answer = n;
    
    for (char c : control.toCharArray()) {
      if (c == 'w') {
        answer += 1;
      } else if (c == 's') {
        answer -= 1;
      } else if (c == 'd') {
        answer += 10;
      } else {
        answer -= 10;
      } 
    }
    
    return answer;
  }
}
```

<mark>수 조작하기 2</mark>
```
class Solution {
  public String solution(int[] numLog) {
    String answer = "";
    
    for (int i = 0; i < numLog.length-1; i++) {
      int move = numLog[i+1] - numLog[i];
      
      switch (move) {
        case 1:
          answer += "w";
          break;
        case -1:
          answer += "s";
          break;
        case 10:
          answer += "d";
          break;
        case -10:
          answer += "a";
          break;
      }
    }
    
    return answer;
  }
}
```
아래처럼, i를 1부터 시작해도 동일하게 구현할 수 있습니다.
```
class Solution {
  public String solution(int[] numLog) {
    String answer = "";
    
    for (int i = 1; i < numLog.length; i++) {
      int move = numLog[i] - numLog[i-1];
      
      switch (move) {
        case 1:
          answer += "w";
          break;
        case -1:
          answer += "s";
          break;
        case 10:
          answer += "d";
          break;
        case -10:
          answer += "a";
          break;
      }
    }
    
    return answer;
  }
}
```

<mark>간단한 논리 연산</mark>
```
```

<mark>주사위 게임 3</mark>
```
```

<mark>배열의 원소 삭제하기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] arr, int[] delete_list) {
    Set<Integer> delSet = new HashSet<>();
    List<Integer> list = new ArrayList<>();
    
    for (int i = 0; i < delete_list.length; i++) {
      delSet.add(delete_list[i]);
    }
    
    for (int i = 0; i < arr.length; i++) {
      if (!delSet.contains(arr[i])) {
        list.add(arr[i]);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```
```
import java.util.*;

class Solution {
  public int[] solution(int[] arr, int[] delete_list) {
    List<Integer> list = new ArrayList<>();
    
    for (int i = 0; i < arr.length; i++) {
      list.add(arr[i]);
    }
    
    for (int i = 0; i < delete_list.length; i++) {
      // 형변환 하지 않으면 int형이라서 index에 해당하는 원소 삭제하여 에러 발생
      // Integer로 형변환 하면 값에 해당하는 원소 삭제하여 정상 작동
      list.remove((Integer) delete_list[i]);
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>부분 문자열인지 확인하기</mark>
```
class Solution {
  public int solution(String my_string, String target) {
    return my_string.contains(target)? 1 : 0;
  }
}
```

<mark>부분 문자열</mark>
```
class Solution {
  public int solution(String str1, String str2) {
    return str2.contains(str1)? 1 : 0;
  }
}
```

<mark>꼬리 문자열</mark>
```
import java.util.*;

class Solution {
  public String solution(String[] str_list, String ex) {
    StringBuilder sb = new StringBuilder();
    
    for (String str : str_list) {
      if (!str.contains(ex)) {
        sb.append(str);
      }
    }
    
    return sb.toString();
  }
}
```

<mark>정수 찾기</mark>
```
class Solution {
  public int solution(int[] num_list, int n) {
    int answer = 0;
    
    for (int num : num_list) {
      if (num == n) {
        answer = 1;
      }
    }
    
    return answer;
  }
}
```

<mark>주사위 게임 1</mark>
```
class Solution {
  public int solution(int a, int b) {
    if (a % 2 == 1 && b % 2 == 1) {
      return a*a + b*b;
    } else if (a % 2 == 1 || b % 2 == 1) {
      return 2 * (a + b);
    } else {
      return Math.abs(a - b);
    }
  }
}
```

<mark>날짜 비교하기</mark>
```
class Solution {
  public int solution(int[] date1, int[] date2) {
    String date1Str = "";
    String date2Str = "";
    
    for (int d1 : date1) {
      date1Str += d1;
    }
    
    for (int d2 : date2) {
      date2Str += d2;
    }
    
    return Integer.parseInt(date1Str) < Integer.parseInt(date2Str) ? 1 : 0;
  }
}
```
java 날짜 비교는 아래처럼 LocalDate 객체를 이용하는 것이 정확합니다.
```
import java.time.LocalDate;

class Solution {
  public int solution(int[] date1, int[] date2) {
      
    LocalDate localDate1 = LocalDate.of(date1[0], date1[1], date1[2]);
    LocalDate localDate2 = LocalDate.of(date2[0], date2[1], date2[2]);
    
    return localDate1.isBefore(localDate2) ? 1 : 0;
  }
}
```
LocalDate에서 제공하는 함수는 isBefore, isAfter, isEqual 등이 있습니다.

<mark>커피 심부름</mark>
```
```

### 반복문 문제 풀이
<mark>수열과 구간 쿼리 3</mark>
```
```

<mark>수열과 구간 쿼리 2</mark>
```
```

<mark>수열과 구간 쿼리 4</mark>
```
```

<mark>배열 만들기 2</mark>
```
```

<mark>카운트 업</mark>
```
class Solution {
  public int[] solution(int start_num, int end_num) {
    int[] answer = new int[end_num - start_num +1];
    
    int index = 0;
    
    for (int i = start_num; i <= end_num; i++) {
      answer[index++] = i;
    }
        
    return answer;
  }
}
```
```
class Solution {
  public int[] solution(int start_num, int end_num) {
    int[] answer = new int[end_num - start_num +1];
    
    for (int i = 0; i <= end_num - start_num; i++) {
      answer[i] = i + start_num;
    }
        
    return answer;
  }
}
```

<mark>콜라츠 수열 만들기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int n) {
    ArrayList<Integer> list = new ArrayList<>();
    
    list.add(n);
    
    while (n > 1) {
      if (n % 2 == 0) {
        n /= 2;
      } else {
        n = 3 * n + 1;
      }
      
      list.add(n);
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>배열 만들기 4</mark>
```
```

<mark>그림 확대</mark>
```
```

<mark>조건에 맞게 수열 변환하기 3</mark>
```
class Solution {
  public int[] solution(int[] arr, int k) {
    int[] answer = new int[arr.length];
    
    for (int i = 0; i < arr.length; i++) {
      if (k % 2 == 1) {
        answer[i] = arr[i] * k;
      } else {
        answer[i] = arr[i] + k;
      }
    }
    
    return answer;
  }
}
```
아래처럼, 한 번만 비교하고 각각의 for문으로 돌리는 것이 더 효율적입니다.
```
class Solution {
  public int[] solution(int[] arr, int k) {
    if (k % 2 == 0) {
      for (int i = 0; i < arr.length; i++) {
        arr[i] = arr[i] + k;
      }
    } else {
      for (int i = 0; i < arr.length; i++) {
        arr[i] = arr[i] * k;
      }
    }
    
    return arr;
  }
}
```

<mark>l로 만들기</mark>
```
import java.util.*;

class Solution {
  public String solution(String myString) {
    StringBuilder sb = new StringBuilder();
    
    for (char c : myString.toCharArray()) {
      if (c - 'l' > 0) {
        sb.append(c);
      } else {
        sb.append('l');
      }
    }
    
    return sb.toString();
  }
}
```
아래처럼, 정규표현식을 이용하면 더 간단하게 변경할 수 있습니다.
```
import java.util.*;

class Solution {
  public String solution(String myString) {
    return myString.replaceAll("[^l-z]", "l");
  }
}
```

### 문자열 문제 풀이
<mark>글자 이어 붙여 문자열 만들기</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string, int[] index_list) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = 0; i < index_list.length; i++) {
      sb.append(my_string.substring(index_list[i], index_list[i]+1));
    }
    
    return sb.toString();
  }
}
```
아래처럼 charAt으로 문자를 추출하면 더 쉽게 이어붙일 수 있습니다.
```
import java.util.*;

class Solution {
  public String solution(String my_string, int[] index_list) {
    StringBuilder sb = new StringBuilder();
    
    for (int index : index_list) {
      sb.append(my_string.charAt(index));
    }
    
    return sb.toString();
  }
}
```

<mark>9로 나눈 나머지</mark>
```
class Solution {
  public int solution(String number) {
    int answer = 0;
    
    for (char c : number.toCharArray()) {
      answer += c - '0';
    }
    
    return answer % 9;
  }
}
```

<mark>문자열 여러 번 뒤집기</mark>
```
```

<mark>배열 만들기 5</mark>
```
import java.util.*;

class Solution {
  public int[] solution(String[] intStrs, int k, int s, int l) {
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int i = 0; i < intStrs.length; i++) {
      int subInt = Integer.parseInt(intStrs[i].substring(s, s+l));
      
      if (subInt > k) {
        list.add(subInt);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>부분 문자열 이어 붙여 문자열 만들기</mark>
```
class Solution {
  public String solution(String[] my_strings, int[][] parts) {
    String answer = "";
    
    for (int i = 0; i < my_strings.length; i++) {
      answer += my_strings[i].substring(parts[i][0], parts[i][1]+1);
    }
    
    return answer;
  }
}
```

<mark>문자열의 뒤의 n글자</mark>
```
class Solution {
  public String solution(String my_string, int n) {
    return my_string.substring(my_string.length()-n);
  }
}
```

<mark>접미사 배열</mark>
```
import java.util.*;

class Solution {
  public String[] solution(String my_string) {
    ArrayList<String> list = new ArrayList<>();
    
    for (int i = 0; i < my_string.length(); i++) {
      list.add( my_string.substring(i) );
    }
    
    Collections.sort(list);
    
    String[] answer = new String[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```
이 문제는 정답 배열 사이즈가 정해져있기 때문에, ArrayList를 사용하지 않아도 풀 수 있습니다.
```
import java.util.*;

class Solution {
  public String[] solution(String my_string) {
    String[] answer = new String[my_string.length()];
    
    for (int i = 0; i < my_string.length(); i++) {
      answer[i] = my_string.substring(i);
    }
    
    Arrays.sort(answer);
    
    return answer;
  }
}
```

<mark>접미사인지 확인하기</mark>
```
class Solution {
  public int solution(String my_string, String is_suffix) {
    int i = my_string.indexOf(is_suffix, my_string.length() - is_suffix.length());
    
    if (my_string.length() < is_suffix.length()) {
      return 0;
    }
    
    return i + is_suffix.length() == my_string.length()? 1 : 0;
  }
}
```
아래처럼, endsWith 함수를 사용하면 접미사인지 더 쉽게 확인할 수 있습니다.
```
class Solution {
  public int solution(String my_string, String is_suffix) {
    if (my_string.endsWith(is_suffix)) {
      return 1;
    }
    
    return 0;
  }
}
```

<mark>문자열의 앞의 n글자</mark>
```
class Solution {
  public String solution(String my_string, int n) {
    return my_string.substring(0, n);
  }
}
```

<mark>접두사인지 확인하기</mark>
```
class Solution {
  public int solution(String my_string, String is_prefix) {
    return my_string.indexOf(is_prefix) == 0? 1 : 0;
  }
}
```
startsWith 함수로 더 간단히 확인할 수 있습니다.
```
class Solution {
  public int solution(String my_string, String is_prefix) {
    return my_string.startsWith(is_prefix)? 1 : 0;
  }
}
```

<mark>문자열 뒤집기</mark>
```
class Solution {
  public String solution(String my_string, int s, int e) {
    String[] myArr = my_string.split("");
    
    for (int i = 0; i <= e - s; i++) {
      myArr[s + i] = String.valueOf(my_string.charAt(e - i));
    }
    
    return String.join("", myArr);
  }
}
```
StringBuilder의 reverse 함수로 문자열을 뒤집으면 메모리와 성능 면에서 더 효율적입니다.
```
class Solution {
  public String solution(String my_string, int s, int e) {
    StringBuilder sb = new StringBuilder(my_string.substring(s, e+1));
    
    sb.reverse();
    
    return my_string.substring(0, s) + sb.toString() + my_string.substring(e+1);
  }
}
```
StringBuilder 생성자에 String을 넘기면, append 함수와 같은 효과입니다.

<mark>세로 읽기</mark>
```
class Solution {
  public String solution(String my_string, int m, int c) {
    String answer = "";
    
    for (int i = 0; i < my_string.length() / m; i++) {
      answer += my_string.charAt((i * m) + c -1);
    }
    
    return answer;
  }
}
```
아래처럼, i의 시작을 c 인덱스부터 하면 더 간결합니다.
```
class Solution {
  public String solution(String my_string, int m, int c) {
    String answer = "";
    
    for (int i = c - 1; i < my_string.length(); i += m) {
      answer += my_string.charAt(i);
    }
    return answer;
  }
}
```

<mark>qr code</mark>
```
```

<mark>원하는 문자열 찾기</mark>
```
class Solution {
  public int solution(String myString, String pat) {
    return myString.toLowerCase().contains(pat.toLowerCase())? 1 : 0;
  }
}
```
contains 함수 뿐 아니라, indexOf 함수로도 문자열 포함 여부를 알 수 있습니다.
```
class Solution {
  public int solution(String myString, String pat) {
    return myString.toLowerCase().indexOf(pat.toLowerCase()) != -1? 1 : 0;
  }
}
```

<mark>대문자로 바꾸기</mark>
```
class Solution {
  public String solution(String myString) {
    return myString.toUpperCase();
  }
}
```

<mark>소문자로 바꾸기</mark>
```
class Solution {
  public String solution(String myString) {
    return myString.toLowerCase();
  }
}
```

<mark>배열에서 문자열 대소문자 변환하기</mark>
```
class Solution {
  public String[] solution(String[] strArr) {
    for (int i = 0; i < strArr.length; i++) {
      if (i % 2 == 1) {
        strArr[i] = strArr[i].toUpperCase();
      } else {
        strArr[i] = strArr[i].toLowerCase();
      }
    }
    
    return strArr;
  }
}
```

<mark>A 강조하기</mark>
```
class Solution {
  public String solution(String myString) {
    return myString.toLowerCase().replaceAll("a", "A");
  }
}
```

<mark>특정한 문자를 대문자로 바꾸기</mark>
```
class Solution {
  public String solution(String my_string, String alp) {
    return my_string.replaceAll(alp, alp.toUpperCase());
  }
}
```

<mark>특정 문자열로 끝나는 가장 긴 부분 문자열 찾기</mark>
```
class Solution {
  public String solution(String myString, String pat) {
    String answer = "";
    
    for (int i = myString.length(); i >= 0; i--) {
      String subStr = myString.substring(0, i);
      
      if (subStr.endsWith(pat)) {
        answer = subStr;
        break;
      }
    }
    
    return answer;
  }
}
```
뒤에서부터 문자 Index를 찾는 lastIndexOf 함수를 사용하면 더 효율적입니다.
```
class Solution {
  public String solution(String myString, String pat) {
    int e = myString.lastIndexOf(pat);
    
    return myString.substring(0, e + pat.length());
  }
}
```

<mark>문자열이 몇 번 등장하는지 세기</mark>
```
```

<mark>ad 제거하기</mark>
```
import java.util.*;

class Solution {
  public String[] solution(String[] strArr) {
    ArrayList<String> list = new ArrayList<>();
    
    for (String str : strArr) {
      if (!str.contains("ad")) {
        list.add(str);
      }
    }
    
    String[] answer = new String[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>공백으로 구분하기 1</mark>
```
class Solution {
  public String[] solution(String my_string) {
    return my_string.split(" ");
  }
}
```

<mark>공백으로 구분하기 2</mark>
```
import java.util.*;

class Solution {
  public String[] solution(String my_string) {
    String[] my_arr = my_string.split(" ");
    List<String> list = new ArrayList<>();
    
    for (String str : my_arr) {
      if (!str.isEmpty()) {
        list.add(str);
      }
    }
    
    String[] answer = new String[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```
아래처럼, 좌우 공백을 trim으로 제거하고 정규표현식으로 하나 이상의 공백을 자르면 좋습니다.
```
class Solution {
  public String[] solution(String my_string) {
    return my_string.trim().split("[ ]+");
  }
}
```

<mark>x 사이의 개수</mark>
```
import java.util.*;

class Solution {
  public int[] solution(String myString) {
    myString = myString + " ";
    
    String[] myArr = myString.split("x");
    int[] answer = new int[myArr.length];
    
    for (int i = 0; i < myArr.length; i++) {
      answer[i] = myArr[i].trim().length();
    }
    
    return answer;
  }
}
```

<mark>문자열 잘라서 정렬하기</mark>
```
import java.util.*;

class Solution {
  public String[] solution(String myString) {
    String[] myArr = myString.split("x");
    
    Arrays.sort(myArr);
    
    ArrayList<String> list = new ArrayList<>();
    
    for (String myStr : myArr) {
      if (!"".equals(myStr)) {
        list.add(myStr);
      }
    }
    
    String[] answer = new String[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>간단한 식 계산하기</mark>
```
class Solution {
  public int solution(String binomial) {
    int answer = 0;
    
    String[] strArr = binomial.split(" ");
    
    if (strArr[1].equals("+")) {
      answer = Integer.parseInt(strArr[0]) + Integer.parseInt(strArr[2]);
    } else if (strArr[1].equals("-")) {
      answer = Integer.parseInt(strArr[0]) - Integer.parseInt(strArr[2]);
    } else {
      answer = Integer.parseInt(strArr[0]) * Integer.parseInt(strArr[2]);
    }
    
    return answer;
  }
}
```

<mark>문자열 바꿔서 찾기</mark>
```
import java.util.*;

class Solution {
  public int solution(String myString, String pat) {
    StringBuilder sb = new StringBuilder();
    
    for (char c : myString.toCharArray()) {
      if (c == 'A') {
        sb.append('B');
      } else {
        sb.append('A');
      }
    }
    
    myString = sb.toString();
    
    return myString.contains(pat)? 1 : 0;
  }
}
```
이래처럼, replace를 이용하면 더 간결하게 A와 B를 바꿀 수 있습니다.
```
class Solution {
  public int solution(String myString, String pat) {
    myString = myString.replace("A", "a").replace("B", "A").replace("a", "B");
    return myString.contains(pat)? 1 : 0;
  }
}
```

<mark>rny_string</mark>
```
class Solution {
  public String solution(String rny_string) {
    return rny_string.replaceAll("m", "rn");
  }
}
```

<mark>세 개의 구분자</mark>
```
```

### 배열 문제 풀이

<mark>문자 개수 세기</mark>
```
```

<mark>배열 만들기 1</mark>
```
class Solution {
  public int[] solution(int n, int k) {
    int[] answer = new int[n / k];
    
    for (int i = 1; i <= n; i++) {
      if (i % k == 0) {
        answer[i / k -1] = i;
      }
    }
    
    return answer;
  }
}
```

<mark>글자 지우기</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string, int[] indices) {
    Arrays.sort(indices);
    
    for (int i = indices.length -1; i >= 0; i--) {
      my_string = my_string.substring(0, indices[i]) + my_string.substring(indices[i]+1);
    }
    
    return my_string;
  }
}
``` 
아래처럼, split과 join 함수를 활용하면 문자열을 쉽게 지울 수 있습니다.
```
class Solution {
  public String solution(String my_string, int[] indices) {
    String[] myArr = my_string.split("");
    
    for (int i = 0; i < indices.length; i++) {
      myArr[indices[i]] = "";
    }
    
    return String.join("", myArr);
  }
}
```

<mark>카운트 다운</mark>
```
class Solution {
  public int[] solution(int start, int end_num) {
    int[] answer = new int[start - end_num +1];
    
    for (int i = start; i >= end_num; i--) {
      answer[start - i] = i;
    }
    
    return answer;
  }
}
```

<mark>가까운 1 찾기</mark>
```
class Solution {
  public int solution(int[] arr, int idx) {
    int answer = -1;
    
    for (int i = idx; i < arr.length; i++) {
      if (arr[i] == 1) {
        return i;
      }
    }
    return answer;
  }
}
```
위 코드처럼 바로 return 하지 않으면, break문이 필요합니다.
```
class Solution {
  public int solution(int[] arr, int idx) {
    int answer = -1;
    
    for (int i = idx; i < arr.length; i++) {
      if (arr[i] == 1) {
        answer = i;
        break;
      }
    }
    return answer;
  }
}
```


<mark>리스트 자르기</mark>
```
```

<mark>첫 번째로 나오는 음수</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int answer = -1;
    
    for (int i = 0; i < num_list.length; i++) {
      if (num_list[i] < 0) {
        answer = i;
        break;
      }
    }
    
    return answer;
  }
}
```

<mark>배열 만들기 3</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] arr, int[][] intervals) {
    int[] arr1 = Arrays.copyOfRange(arr, intervals[0][0], intervals[0][1]+1);
    int[] arr2 = Arrays.copyOfRange(arr, intervals[1][0], intervals[1][1]+1);
    
    int[] answer = new int[arr1.length + arr2.length];
    
    int idx = 0;
    
    for (int i = 0; i < arr1.length; i++) {
      answer[idx++] = arr1[i];
    }
    
    for (int i = 0; i < arr2.length; i++) {
      answer[idx++] = arr2[i];
    }
    
    return answer;
  }
}
```
intervals[0] 인덱스 구간 arr1 배열과 intervals[1] 인덱스 구간 arr2 배열을 이어붙이는 문제입니다.  
어차피 배열을 이어붙이기 위해 for문을 사용하므로, copyOfRange 함수는 필요하지 않습니다.
```
import java.util.*;

class Solution {
  public int[] solution(int[] arr, int[][] intervals) {
    int s1 = intervals[0][0];
    int e1 = intervals[0][1];
    int s2 = intervals[1][0];
    int e2 = intervals[1][1];
    
    int[] answer = new int[(e1 - s1 +1) + (e2 - s2 +1)];
    
    int idx = 0;
    
    for (int i = s1; i <= e1; i++) {
      answer[idx++] = arr[i];
    }
    
    for (int i = s2; i <= e2; i++) {
      answer[idx++] = arr[i];
    }
    
    return answer;
  }
}
```

<mark>2의 영역</mark>
```
```

<mark>배열 조각하기</mark>
```
```

<mark>n 번째 원소부터</mark>
```
class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] answer = new int[num_list.length -n +1];
    
    for (int i = n; i <= num_list.length; i++) {
      answer[i-n] = num_list[i-1];
    }
    
    return answer;
  }
}
```
아래처럼, copyOfRange를 사용하면 배열을 쉽게 자를 수 있습니다.
```
import java.util.*;

class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] answer = Arrays.copyOfRange(num_list, n-1, num_list.length);
    
    return answer;
  }
}
```

<mark>순서 바꾸기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] array1 = Arrays.copyOfRange(num_list, n, num_list.length);
    int[] array2 = Arrays.copyOfRange(num_list, 0, n);
    int[] answer = new int[array1.length + array2.length];
    
    for (int i = 0; i < array1.length; i++) {
      answer[i] = array1[i];
    }
    
    for (int i = 0; i < array2.length; i++) {
      answer[array1.length + i] = array2[i];
    }
    
    return answer;
  }
}
```
아래처럼, 인덱스를 하나로 공유해서 쓰는 방법이 더 효율적입니다.
```
class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] answer = new int[num_list.length];
    int idx = 0;
    
    for (int i = n; i < num_list.length; i++) {
      answer[idx++] = num_list[i];
    }
    
    for (int i = 0; i < n; i++) {
      answer[idx++] = num_list[i];
    }
    
    return answer;
  }
}
```

<mark>왼쪽 오른쪽</mark>
```
```

<mark>n번째 원소까지</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] num_list, int n) {
    int[] answer = Arrays.copyOfRange(num_list, 0, n);
    return answer;
  }
}
```

<mark>n개 간격의 원소들</mark>
```
import java.util.ArrayList;

class Solution {
  public int[] solution(int[] num_list, int n) {
      
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int i = 0; i < num_list.length; i++) {
      if (i % n == 0) {
        list.add(num_list[i]);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
        
    return answer;
  }
}
```

<mark>홀수 vs 짝수</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int even = 0;
    int odd = 0;
    
    for (int i = 0; i < num_list.length; i++) {
      int num = num_list[i];
      
      if (i % 2 == 0) {
        even += num;
      } else {
        odd += num;
      }
    }
    
    return Math.max(even, odd);
  }
}
```

<mark>5명씩</mark>
```
class Solution {
  public String[] solution(String[] names) {
    String[] answer = new String[(names.length + 4) / 5];
    int idx = 0;
    
    for (int i = 0; i < names.length; i += 5) {
      answer[idx++] = names[i];
    }
    
    return answer;
  }
}
```
아래처럼, i*5번째 값을 이용하면 인덱스 하나로 구현 가능합니다.
```
class Solution {
  public String[] solution(String[] names) {
    String[] answer = new String[((names.length-1) / 5) +1];
    
    for (int i = 0; i < answer.length; i++) {
        answer[i] = names[i * 5];
    }
    
    return answer;
  }
}
```

<mark>할 일 목록</mark>
```
import java.util.*;

class Solution {
  public String[] solution(String[] todo_list, boolean[] finished) {
    List<String> list = new ArrayList<>();
    
    for (int i = 0; i < todo_list.length; i++) {
      if (!finished[i]) {
        list.add(todo_list[i]);
      }
    }
    
    String[] answer = new String[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```
아래처럼, ArrayList를 쓰지 않고 문자열 더하기 후 split으로 구현하는 방법도 있습니다.
```
class Solution {
  public String[] solution(String[] todo_list, boolean[] finished) {
    String answer = new String();
    
    for (int i = 0; i < todo_list.length; i++) {
      if (!finished[i]) {
        answer += todo_list[i] + ",";
      }
    }
    
    return answer.split(",");
  }
}
```

<mark>n보다 커질 때까지 더하기</mark>
```
class Solution {
  public int solution(int[] numbers, int n) {
    int answer = 0;
    
    for (int v : numbers) {
      answer += v;
      
      if (answer > n) {
        break;
      }
    }
    
    return answer;
  }
}
```

<mark>수열과 구간 쿼리 1</mark>
```
class Solution {
  public int[] solution(int[] arr, int[][] queries) {
    for (int i = 0; i < queries.length; i++) {
      for (int s = queries[i][0]; s <= queries[i][1]; s++) {
        arr[s]++;
      }
    }
    
    return arr;
  }
}
```

<mark>조건에 맞게 수열 변환하기 1</mark>
```
class Solution {
  public int[] solution(int[] arr) {
    int[] answer = {};
    
    for (int i = 0; i < arr.length; i++) {
      int v = arr[i];
      
      if (v >= 50 && v % 2 == 0) {
        arr[i] = v / 2;
      }
          
      if (v < 50 && v % 2 == 1) {
        arr[i] = v * 2;
      }
    }
    
    return arr;
  }
}
```

<mark>조건에 맞게 수열 변환하기 2</mark>
```
```

<mark>1로 만들기</mark>
```
```

<mark>길이에 따른 연산</mark>
```
class Solution {
  public int solution(int[] num_list) {
    int sum = 0;
    int gob = 1;
    
    for (int i = 0; i < num_list.length; i++) {
      sum += num_list[i];
      gob *= num_list[i];
    }
    
    return num_list.length > 10? sum : gob;
  }
}
```

<mark>배열의 원소만큼 추가하기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] arr) {
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int v : arr) {
      for (int i = 0; i < v; i++) {
        list.add(v);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>빈 배열에 추가, 삭제하기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] arr, boolean[] flag) {
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int i = 0; i < arr.length; i++) {
      if (flag[i]) {
        for (int j = 0; j < arr[i] * 2; j++) {
          list.add(arr[i]);
        }
      } else {
        for (int j = 0; j < arr[i]; j++) {
          list.remove(list.size()-1);
        }
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>배열 만들기 6</mark>
```
```

<mark>무작위로 K개의 수 뽑기</mark>
```
```

### 이차원 배열 문제 풀이

<mark>특별한 이차원 배열 1</mark>
```
class Solution {
  public int[][] solution(int n) {
    int[][] answer = new int[n][];
    
    for (int i = 0; i < n; i++) {
      answer[i] = new int[n];
      answer[i][i] = 1;
    }
    
    return answer;
  }
}
```
n x n 배열이므로, 아래처럼 배열 초기화 시 모두 생성해도 됩니다.
```
class Solution {
  public int[][] solution(int n) {
    int[][] answer = new int[n][n];
    
    for (int i = 0; i < n; i++) {
      answer[i][i] = 1;
    }
    
    return answer;
  }
}
```

<mark>정수를 나선형으로 배치하기</mark>
```
```

<mark>특별한 이차원 배열 2</mark>
```
class Solution {
  public int solution(int[][] arr) {
    int answer = 1;
    
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr.length; j++) {
        if (arr[i][j] != arr[j][i]) {
          answer = 0;
          break;
        }
      }
    }
    
    return answer;
  }
}
```

<mark>정사각형으로 만들기</mark>
```
```

<mark>이차원 배열 대각선 순회하기</mark>
```
class Solution {
  public int solution(int[][] board, int k) {
    int answer = 0;
    
    for (int i = 0; i < board.length; i++) {
      for (int j = 0; j < board[i].length; j++) {
        if (i + j <= k) {
          answer += board[i][j];
        }
      }
    }
    
    return answer;
  }
}
```

### 함수 문제 풀이
<mark>배열의 길이를 2의 거듭제곱으로 만들기</mark>
```
```

<mark>배열 비교하기</mark>
```
class Solution {
  public int solution(int[] arr1, int[] arr2) {
    int answer = 0;
    
    if (arr1.length > arr2.length) {
      answer = 1;
    } else if (arr1.length < arr2.length) {
      answer = -1;
    } else {
      int arr1Sum = 0;
      for (int v : arr1) {
        arr1Sum += v;
      }
      
      int arr2Sum = 0;
      for (int v : arr2) {
        arr2Sum += v;
      }
      
      if (arr1Sum > arr2Sum) {
        answer = 1;
      } else if (arr1Sum < arr2Sum) {
        answer = -1;
      } else {
        answer = 0;
      }
    }
    
    return answer;
  }
}
```

<mark>문자열 묶기</mark>
```
```

<mark>배열의 길이에 따라 다른 연산하기</mark>
```
class Solution {
  public int[] solution(int[] arr, int n) {
    if (arr.length % 2 == 1) {
      for (int i = 0; i < arr.length; i++) {
        if (i % 2 == 0) {
          arr[i] += n;
        }
      }
    } else {
      for (int i = 0; i < arr.length; i++) {
        if (i % 2 == 1) {
          arr[i] += n;
        }
      }
    }
    
    return arr;
  }
}
```
아래처럼, 하나의 for문으로 구현할 수도 있습니다.
```
class Solution {
  public int[] solution(int[] arr, int n) {
    for (int i = arr.length % 2 == 1? 0 : 1; i < arr.length; i+=2) {
      arr[i] += n;
    }
    
    return arr;
  }
}
```

<mark>뒤에서 5등까지</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] num_list) {
    Arrays.sort(num_list);
    
    return Arrays.copyOfRange(num_list, 0, 5);
  }
}
```

<mark>뒤에서 5등 위로</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] num_list) {
    Arrays.sort(num_list);
    
    return Arrays.copyOfRange(num_list, 5, num_list.length);
  }
}
```

<mark>전국 대회 선발 고사</mark>
```
```

<mark>정수 부분</mark>
```
class Solution {
  public int solution(double flo) {
    return (int) flo;
  }
}
```

<mark>문자열 정수의 합</mark>
```
class Solution {
  public int solution(String num_str) {
    int answer = 0;
    String[] num_arr = num_str.split("");
    
    for (String num : num_arr) {
      answer += Integer.parseInt(num);
    }
    
  return answer;
  }
}
```

<mark>문자열을 정수로 변환하기</mark>
```
class Solution {
  public int solution(String n_str) {
    return Integer.parseInt(n_str);
  }
}
```

<mark>0 떼기</mark>
```
class Solution {
  public String solution(String n_str) {
    String answer = "";
    int length = n_str.length();
    
    for (int i = 0; i < length; i++) {
      char c = n_str.charAt(0);
      
      if (c == '0') {
        n_str = n_str.replaceFirst("0", "");
              
      } else {
          answer = n_str;
        break;
      }
    }
    
    return answer;
  }
}
```
아래와 같이, 정수로 변환 후 문자열로 변환해도 왼쪽의 0을 제거할 수 있습니다.
```
class Solution {
  public String solution(String n_str) {
    return String.valueOf(Integer.parseInt(n_str));
  }
}
```

<mark>두 수의 합</mark>
```
```

<mark>문자열로 변환</mark>
```
class Solution {
  public String solution(int n) {
    return String.valueOf(n);
  }
}
```