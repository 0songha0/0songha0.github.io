---
title: "코딩 테스트 합격자 되기 Java 책 요약 / 코딩테스트 사전 준비"
excerpt: ""

categories:
  - 파이썬 / 코딩테스트
tags:
  - []

permalink: /python/2024-04-30-1

toc: true
toc_sticky: true

date: 2024-04-30
last_modified_at: 2024-04-30
---

## 코테 문제 푸는 방법

1. 문제와 제약사항을 분석하며, 코드 설계를 주석으로 작성합니다.
2. 입력 값의 크기가 10의 8승(1억) 이상이면, 시간복잡도 O(n) 이하 자료구조/알고리즘을 선택합니다.
제한시간이 1초인 문제에 O(n²) 자료구조/알고리즘을 사용하려면 입력 값이 5,000 이내여야 합니다.
컴퓨터가 초당 연산할 수 있는 최대 횟수는 1억 번이기 때문입니다.
4. 코드 설계에 따라 구현하고, 테스트 케이스를 통과할 수 있게 합니다.

### Java 코드 실행시간 게산
```
long start = System.currentTimeMillis();

// 실행시간을 계산할 코드 작성

long end = System.currentTimeMillis();

System.out.println(((end - start) / 1000.0) + "초");

```

---

## 핵심 키워드로 자료구조/알고리즘 선택

작성예정

---

## Java 문법 및 자료구조

### 변수 타입
`프리미티브 타입` : int, long, float, double 등  
`레퍼런스 타입` : Integer, Long, Float, Double 등  
참조형 변수인 레퍼런스 타입은 메모리에 직접 값을 저장하는 프리미티브 타입보다 연산 속도가 느리고, 컬렉션 프레임워크에 저장할 때 주로 사용됩니다.

### 정수형 연산
```
// 더하기
a + b

// 빼기
a - b

// 곱하기
a * b

// 나누기 (소수점 버림)
a / b

// 나눈 나머지 반환 (소수점 버림)
a % b
```

### 문자열 수정
Java에서 String은 값을 변경할 수 없는 객체이므로, 기존 객체를 수정하지 않고 새로운 객체를 반환합니다.

<mark>String 사용법</mark>
```
// 비효율적 문자열 더하기 (값 복사 n * 값 저장 n) : O(n²)
String str = "문자열";
System.out.println(System.identityHashCode(str)); // 객체 해시코드 : 1808253012
str += "문자열2";
System.out.println(System.identityHashCode(str)); // 객체 해시코드 : 589431969으로 달라짐 (다른 객체)

// 효율적 문자열 삭제
str = str.replace("1", ""); // 문자열에서 "1" 전체 삭제

// 0번째부터 5번째 앞까지 문자열 추출
str.substring(0, 5);
```

<mark>StringBuilder 사용법</mark>
```
// StringBuilder를 이용한 효율적 문자열 더하기
StringBuilder sb = new StringBuilder();
sb.append("문자열");
sb.append("문자열2");

// 3번째 문자열 삭제
sb.deleteCharAt(3);

// 1번째 인덱스에 문자열 추가
sb.insert(1, "문자열");
```
멀티스레드 환경에서는 Thread-Safe 한 StringBuffer를 사용해야 합니다.

### Java 자료구조 문법
`배열 (Array)` : 배열 크기를 변경할 수 없으므로, 데이터의 개수가 정해져 있을 때 사용합니다.
```
import java.util.Arrays;

public class Solution {
  public static void main(String[] args) {

  // 배열 초기화
  int[] array = { 1, 2, 3, 4, 5 };
  int[] array2 = new int[] { 1, 3, 5, 7, 9 };
  int[] array3 = new int[5];

  // 0번째 원소 값을 1으로 변경 : O(1)
  array3[0] = 1;

  // 3번째 값에 접근 및 출력
  System.out.println(array2[2]);

  // 배열 전체 출력
  System.out.println(Arrays.toString(array));
  // [1, 2, 3, 4, 5]
  }
}
```

`리스트 (ArrayList)` : 가변 크기이므로 데이터를 자유롭게 삽입/삭제할 수 있습니다.
```
// 리스트 초기화
ArrayList<Integer> list = new ArrayList<>();

// 리스트 마지막에 값 추가 : O(1)
list.add(값);

// 리스트 첫번째에 값 추가 : O(n)
list.add(0, 값);

// 리스트의 0번째 원소 출력
System.out.println(list.get(0));

// 리스트 전체 출력
System.out.println(list);
```

`해시맵 (HashMap)` : 키와 값의 쌍을 저장할 수 있습니다.
```
// 해시맵 초기화
HashMap<String, Integer> map = new HashMap<>();

// 해시맵 값 삽입 및 수정
map.put("키", 값);

// 해시맵에서 키-값 삭제
map.remove("키");

// 해시맵에 키가 있는지 확인
if (map.containsKey("키")) {
  System.out.println("키 : " + map.get("키"));
}

// 해시맵에 값이 있는지 확인
// if (map.containsValue(값)) {
  System.out.println("값이 존재합니다."));
}

// 해시맵 전체 출력
System.out.println(map);
```

`스택 (Stack)` : 

`큐 (Queue)` : 

`데크 (ArrayDeque)` : 

---

## 알고리즘 개념 정리

### 해시

### 트리

### 집합

### 그래프

### 백트래킹

### 정렬

### 시뮬레이션

### 동적계획법
