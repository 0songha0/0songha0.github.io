---
title: "프로그래머스 코딩테스트 고득점 Kit 47문제 Java 풀이"
excerpt: ""

categories:
  - 파이썬 / 코딩테스트
tags:
  - []

permalink: /python/2023-08-23-1

toc: true
toc_sticky: true
 
date: 2023-08-23
last_modified_at: 2023-08-23
---

<mark>대기업 코테 난이도</mark>  
보통 프로그래머스 LV.3, 코드포스 블루 레벨이면 무난하게 풀 수 있다고 합니다.  
LV.4 문제까지는 잘 안 나와서, 우선 건너 띄우고 공부할 예정입니다.

<mark>코테 문제 풀이 방법</mark>
1. 최대한 문제의 요구사항을 이해하며 풀어봅니다.
2. 30분 넘게 문제를 풀지 못하면, 검색하여 답안을 확인합니다.
3. 이해 안 되는 코드는 디버깅하거나 코드 설명을 보고 완벽하게 이해합니다.
4. 시간이 지난 후, 모든 코드를 지우고 다시 풀어봅니다.
5. 코드를 완벽하게 외워서 구현할 수 있을 때까지 반복하여 풉니다.

---

## 프로그래머스 코딩테스트 고득점 Kit 47문제

<https://school.programmers.co.kr/learn/challenges?tab=algorithm_practice_kit>{: target="_blank"}  

<mark>난이도 낮은 순서</mark>  
정렬, 스택/큐, 완전탐색 > 힙, 해시, 깊이/너비 우선 탐색(DFS/BFS), 탐욕법(Greedy) > 동적계획법(DP), 이분탐색, 그래프  
코테 준비 기간이 여유롭다면, 쉬운 유형부터 천천히 풀어나가는 것이 좋습니다.

<mark>출제 빈도 높은 순서</mark>  
깊이/너비 우선 탐색(DFS/BFS), 완전탐색, 정렬, 해시 > 스택/큐, 힙 > 동적계획법(DP), 그래프, 탐욕법(Greedy), 이분탐색  
코테를 준비할 시간이 없다면, 가장 출제 빈도가 높은 DFS/BFS를 우선 공부해야 합니다.

### 해시 문제 풀이
<mark>LV.1 폰켓몬</mark>
```
import java.util.HashSet;

class Solution {
  public int solution(int[] nums) {

    HashSet<Integer> hs = new HashSet<>();

    for(int i =0; i<nums.length;i++) {
      hs.add(nums[i]);
    }

    if(hs.size()>nums.length/2)
      return nums.length/2;

    return hs.size();
  }
}
```
HashSet은 중복된 요소를 없애줍니다.

<mark>LV.1 완주하지 못한 선수</mark>
```
import java.util.HashMap;

class Solution {
  public String solution(String[] participant, String[] completion) {
    String answer = "";
    HashMap<String, Integer> hm = new HashMap<>();
    for (String player : participant) hm.put(player, hm.getOrDefault(player, 0) + 1);
    for (String player : completion) hm.put(player, hm.get(player) - 1);

    for (String key : hm.keySet()) {
      if (hm.get(key) != 0){
        answer = key;
      }
    }

    return answer;
  }
}
```

<mark>LV.2 전화번호 목록</mark>
```
import java.util.HashMap;

class Solution {
  public boolean solution(String[] phoneBook) {
    boolean answer = true;

    HashMap<String, Integer> map = new HashMap<>();

    for(int i = 0; i < phoneBook.length; i++) {
      map.put(phoneBook[i], i);
    }

    for(int i = 0; i < phoneBook.length; i++) {
      for(int j = 0; j < phoneBook[i].length(); j++) {
        if(map.containsKey(phoneBook[i].substring(0,j))) {
          answer = false;
          return answer;
        }
      }
    }

    return answer;
  }
}
```

<mark>LV.2 의상</mark>
```
import java.util.HashMap;
import java.util.Iterator;

class Solution {
  public int solution(String[][] clothes) {
    int answer = 1;
    HashMap<String, Integer> map = new HashMap<>();
    
    for(int i = 0; i < clothes.length; i++){
      String key = clothes[i][1];
      if(!map.containsKey(key)) {
        map.put(key, 1);
      } else {
        map.put(key, map.get(key) + 1);
      }
    }
    
    Iterator<Integer> it = map.values().iterator();
    
    while(it.hasNext()) {
      answer *= it.next().intValue()+1;
    }
    
    return answer-1;
  }
}
```

<mark>LV.3 베스트앨범</mark>
```
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.Collections;

class Solution {
  public int[] solution(String[] genres, int[] plays) {
    // 장르, 곡 정보
    HashMap<String, Object> genresMap = new HashMap<String, Object>();
    // 장르, 총 장르 재생수
    HashMap<String, Integer> playMap = new HashMap<String, Integer>();
    ArrayList<Integer> resultAL = new ArrayList<Integer>();

    for(int i = 0; i < genres.length; i++){
      String key = genres[i];
      // 곡 정보 : 곡 고유번호, 재생횟수
      HashMap<Integer, Integer> infoMap;

      if(genresMap.containsKey(key)){
        infoMap = (HashMap<Integer, Integer>)genresMap.get(key);
      } else {
        infoMap = new HashMap<Integer, Integer>();
      }

      infoMap.put(i, plays[i]);
      genresMap.put(key, infoMap);

      // 재생수
      if(playMap.containsKey(key)){
        playMap.put(key, playMap.get(key) + plays[i]);
      } else {
        playMap.put(key, plays[i]);
      }
    }

    int mCnt = 0;
    Iterator it = sortByValue(playMap).iterator();

    while(it.hasNext()){
      String key = (String)it.next();
      Iterator indexIt = sortByValue((HashMap<Integer, Integer>)genresMap.get(key)).iterator();
      int playsCnt = 0;

      while(indexIt.hasNext()){
        resultAL.add((int)indexIt.next());
        mCnt++;
        playsCnt++;
        if(playsCnt > 1) break;
      }
    }

    int[] answer = new int[resultAL.size()];

    for(int i = 0; i < resultAL.size(); i++){
      answer[i] = resultAL.get(i).intValue();
    }

    return answer;
  }

  private ArrayList sortByValue(final Map map){
    ArrayList<Object> keyList = new ArrayList();
    keyList.addAll(map.keySet());

    Collections.sort(keyList, new Comparator(){
      public int compare(Object o1, Object o2){
        Object v1 = map.get(o1);
        Object v2 = map.get(o2);

        return ((Comparable) v2).compareTo(v1);
      }
    });

    return keyList;
  }
}
```

### 스택/큐 문제 풀이
<mark>LV.1 같은 숫자는 싫어</mark>
```
import java.util.*;

public class Solution {
  public int[] solution(int []arr) {
    List<Integer> list = new ArrayList<Integer>();
    list.add(arr[0]);

    for (int i = 1; i < arr.length; i++) {
      if (arr[i] != arr[i - 1])
        list.add(arr[i]);
    }

    int[] answer = new int[list.size()];

    for (int i = 0; i < list.size(); i++)
      answer[i] = list.get(i);

    return answer;
  }
}
```

<mark>LV.2 기능개발</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] progresses, int[] speeds) {
    Queue<Integer> q = new LinkedList<>();
    List<Integer> answerList = new ArrayList<>();

    for (int i = 0; i < speeds.length; i++) {
      double remain = (100 - progresses[i]) / (double) speeds[i];
      int date = (int) Math.ceil(remain);

      if (!q.isEmpty() && q.peek() < date) {
        answerList.add(q.size());
        q.clear();
      }

      q.offer(date);
    }

    answerList.add(q.size());

    int[] answer = new int[answerList.size()];

    for (int i = 0; i < answer.length; i++) {
      answer[i] = answerList.get(i);
    }

    return answer;
  }
}
```

<mark>LV.2 올바른 괄호</mark>
```
class Solution {
  boolean solution(String s) {
    boolean answer = false;
    int count = 0;
    for(int i = 0; i < s.length(); i++) {

      if(s.charAt(i) == '('){
        count++;
      }

      if(s.charAt(i) == ')'){
        count--;
      }

      if(count < 0){
        break;
      }
    }

    if(count == 0){
      answer = true;
    }

    return answer;
  }
}
```

<mark>LV.2 프로세스</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] priorities, int location) {
    int answer = 0;
    int l = location;

    Queue<Integer> que = new LinkedList<Integer>();
    for(int i : priorities){
      que.add(i);
    }

    Arrays.sort(priorities);
    int size = priorities.length-1;

    while(!que.isEmpty()){
      Integer i = que.poll();
      if(i == priorities[size - answer]){
        answer++;
        l--;
        if(l <0)
          break;
      }else{
        que.add(i);
        l--;
        if(l<0)
          l=que.size()-1;
      }
    }

    return answer;
  }
}
```

<mark>LV.2 다리를 지나는 트럭</mark>
```
import java.util.*;

class Solution {
  class Truck {
    int weight;
    int move;

    public Truck(int weight) {
      this.weight = weight;
      this.move = 1;
    }

    public void moving() {
      move++;
    }
  }

  public int solution(int bridgeLength, int weight, int[] truckWeights) {
    Queue<Truck> waitQ = new LinkedList<>();
    Queue<Truck> moveQ = new LinkedList<>();

    for (int t : truckWeights) {
      waitQ.offer(new Truck(t));
    }

    int answer = 0;
    int curWeight = 0;

    while (!waitQ.isEmpty() || !moveQ.isEmpty()) {
      answer++;

      if (moveQ.isEmpty()) {
        Truck t = waitQ.poll();
        curWeight += t.weight;
        moveQ.offer(t);
        continue;
      }

      for (Truck t : moveQ) {
        t.moving();
      }

      if (moveQ.peek().move > bridgeLength) {
        Truck t = moveQ.poll();
        curWeight -= t.weight;
      }

      if (!waitQ.isEmpty() && curWeight + waitQ.peek().weight <= weight) {
        Truck t = waitQ.poll();
        curWeight += t.weight;
        moveQ.offer(t);
      }
    }

    return answer;
  }
}
```

<mark>LV.2 주식 가격</mark>
```
import java.util.Stack;

class Solution {
  public int[] solution(int[] prices) {
    Stack<Integer> beginIdxs = new Stack<>();
    int i=0;
    int[] terms = new int[prices.length];

    beginIdxs.push(i);
    for (i=1; i<prices.length; i++) {
      while (!beginIdxs.empty() && prices[i] < prices[beginIdxs.peek()]) {
        int beginIdx = beginIdxs.pop();
        terms[beginIdx] = i - beginIdx;
      }
      beginIdxs.push(i);
    }
    while (!beginIdxs.empty()) {
      int beginIdx = beginIdxs.pop();
      terms[beginIdx] = i - beginIdx - 1;
    }

    return terms;
  }
}
```

### 힙(Heap) 문제 풀이
<mark>LV.2 더 맵게</mark>
```
import java.util.PriorityQueue;

class Solution {
  public int solution(int[] scoville, int K) {
    int answer = 0;
    PriorityQueue<Integer> que = new PriorityQueue<>();
    
    for (int i = 0; i < scoville.length; i++) {
      que.add(scoville[i]);
    }

    while(que.peek() < K) {
      if (que.size() == 1)
        return -1;

      que.add(que.poll() + que.poll() * 2);
      answer++;
    }
    
    return answer;
  }
}
```
힙(완전이진트리)을 이용해서 우선순위 큐를 구현할 수 있습니다.

<mark>LV.3 디스크 컨트롤러</mark>
```
import java.util.Arrays;
import java.util.PriorityQueue;

class Solution {
  public int solution(int[][] jobs) {
    int answer = 0;

    // 작업이 요청되는 시점 기준으로 오름차순 정렬
    Arrays.sort(jobs, (o1, o2) -> o1[0] - o2[0]);

    // 작업의 소요시간 기준으로 오름차순 정렬
    PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);

    int jobs_index = 0; // 작업 배열 인덱스
    int finish_job = 0; // 처리 완료된 작업 개수
    int end_time = 0; // 작업 처리 완료 시간

    while(true) {
      if(finish_job == jobs.length) break; // 모든 작업을 처리했다면 종료

      // 이전 작업 처리 중 요청된 작업 add
      while(jobs_index < jobs.length && jobs[jobs_index][0] <= end_time) {
        pq.add(jobs[jobs_index++]);
      }

      if(!pq.isEmpty()) { // 이전 작업 처리 중 요청된 작업이 있는 경우
        int[] job = pq.poll();
        answer += end_time - job[0] + job[1]; // 작업 요청부터 종료까지 걸린 시간 추가
        end_time += job[1]; // 작업 처리 완료 시간 갱신
        finish_job++; // 처리 완료된 작업 개수 1 증가
      } else { // 이전 작업 처리 중 요청된 작업이 없는 경우
        end_time = jobs[jobs_index][0]; // 다음 작업 요청 시점으로 갱신
      }
    }

    return answer / jobs.length;
  }
}
```

<mark>LV.3 이중우선순위큐</mark>
```
import java.util.*;

class Solution {
  public int[] solution(String[] operations) {
    Queue<Integer> minpq = new PriorityQueue<>();
    Queue<Integer> maxpq = new PriorityQueue<>(Collections.reverseOrder());

    for (String operation : operations) {
      if (operation.startsWith("I ")) {
        int n = Integer.parseInt(operation.substring(2));
        minpq.offer(n);
        maxpq.offer(n);

      } else if (!minpq.isEmpty() && operation.equals("D -1")) {
        maxpq.remove(minpq.poll());

      } else if (!maxpq.isEmpty() && operation.equals("D 1")) {
        minpq.remove(maxpq.poll());
      }
    }

    if (minpq.isEmpty() && maxpq.isEmpty()) {
      return new int[]{0, 0};
    }

    return new int[]{maxpq.poll(), minpq.poll()};
  }
}
```

### 정렬 문제 풀이
<mark>LV.1 K번째수</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] array, int[][] commands) {
    int[] answer = new int[commands.length];
    
    for(int i = 0; i < commands.length; i++) {
      // 이차원 배열에서 배열 추출
      int[] command = Arrays.copyOfRange(array, commands[i][0]-1, commands[i][1]);
      
      // 오름차순 정렬
      Arrays.sort(command);
      
      // K번째 수
      answer[i] = command[commands[i][2]-1];
      
    }
    
    return answer;
  }
}
```
Arrays.toString, Arrays.deepToString 함수로 배열, 이차원배열 출력이 가능합니다.

내림차순 정렬은 Arrays.sort(command, Collections.reverseOrder()); 으로 할 수 있습니다.

<mark>LV.2 가장 큰 수</mark>
```
import java.util.*;

class Solution {
  public String solution(int[] numbers) {
    ArrayList<String> strList = new ArrayList<String>();
    
    // 각 int 원소를 String으로 변환
    for (int i = 0; i < numbers.length; i++) {
        strList.add(String.valueOf(numbers[i]));
    }
    
    // 앞뒤 원소 문자열 조합을 비교하며 오름차순 정렬
    Collections.sort(strList, (o1, o2) -> (o2 + o1).compareTo(o1 + o2));
    
    // 결과 String 연결
    StringBuilder sb = new StringBuilder();
    
    for (String str : strList) {
        sb.append(str);
    }
    
    String answer = sb.toString();
    
    // 원소가 [0, 0, 0]이면 0 반환, 외에는 그대로 반환
    return answer.charAt(0) == '0'? "0" : answer;
  }
}
```
compareTo 함수는 현재 객체가 다른 객체보다 작으면 크면 1, 음수, 같으면 0을 반환합니다.  
(o2 + o1).compareTo(o1 + o2)은 반환값이 1이면 순서를 바꿔서, 내림차순 정렬됩니다.  
(o1 + o2).compareTo(o2 + o1)은 반환값이 1이면 순서를 바꿔서, 오름차순 정렬됩니다.

문자열을 반복하여 더할 때 String += 대신 StringBuilder를 사용하면 메모리 효율적입니다.

answer.charAt(0) == '0' 대신 answer.startsWith("0")를 사용해도 됩니다.

<mark>LV.2 H-Index</mark>
```
import java.util.Arrays;

class Solution {
  public int solution(int[] citations) {
    int answer = 0;
    Arrays.sort(citations);

    for(int i=0; i<citations.length; i++){
      int smaller = Math.min(citations[i], citations.length-i);
      answer = Math.max(answer, smaller);
    }

    return answer;
  }
}
```

### 완전탐색 문제 풀이
<mark>LV.1 최소직사각형</mark>
```
class Solution {
  public int solution(int[][] sizes) {
    int length = 0, height = 0;
    for (int[] card : sizes) {
      length = Math.max(length, Math.max(card[0], card[1]));
      height = Math.max(height, Math.min(card[0], card[1]));
    }
    int answer = length * height;
    return answer;
  }
}
```

<mark>LV.1 모의고사</mark>
```
import java.util.*;

class Solution {
  public static int[] solution(int[] answers) {
    int[][] patterns = {
      {1, 2, 3, 4, 5},
      {2, 1, 2, 3, 2, 4, 2, 5},
      {3, 3, 1, 1, 2, 2, 4, 4, 5, 5}
    };

    int[] hit = new int[3];
    for(int i = 0; i < hit.length; i++) {
      for(int j = 0; j < answers.length; j++) {
        if(patterns[i][j % patterns[i].length] == answers[j]) hit[i]++;
      }
    }

    int max = Math.max(hit[0], Math.max(hit[1], hit[2]));
    List<Integer> list = new ArrayList<>();
    for(int i = 0; i < hit.length; i++)
      if(max == hit[i]) list.add(i + 1);

    int[] answer = new int[list.size()];
    int cnt = 0;
    for(int num : list)
      answer[cnt++] = num;
    return answer;
  }
}
```

<mark>LV.2 소수 찾기</mark>
```
import java.util.HashSet;
class Solution {
  public int solution(String numbers) {
    HashSet<Integer> set = new HashSet<>();
    permutation("", numbers, set);
    int count = 0;
    while(set.iterator().hasNext()){
      int a = set.iterator().next();
      set.remove(a);
      if(a==2) count++;
      if(a%2!=0 && isPrime(a)){
        count++;
      }
    }
    return count;
  }

  public boolean isPrime(int n){
    if(n==0 || n==1) return false;
    for(int i=3; i<=(int)Math.sqrt(n); i+=2){
      if(n%i==0) return false;
    }
    return true;
  }

  public void permutation(String prefix, String str, HashSet<Integer> set) {
    int n = str.length();

    if(!prefix.equals("")) set.add(Integer.valueOf(prefix));

    for (int i = 0; i < n; i++) {
      permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), set);
    }
  }
}
```

<mark>LV.2 카펫</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int brown, int red) {
    int a = (brown+4)/2;
    int b = red+2*a-4;
    int[] answer = {(int)(a+Math.sqrt(a*a-4*b))/2,(int)(a-Math.sqrt(a*a-4*b))/2};
    return answer;
  }
}
```
근의공식을 이용한 풀이 방법입니다.

<mark>LV.2 피로도</mark>
```
class Solution {
  public static boolean check[];
  public static int ans = 0;

  public int solution(int k, int[][] dungeons) {
    check = new boolean[dungeons.length];

    dfs(k, dungeons, 0);

    return ans;
  }

  public static void dfs(int tired, int[][] dungeons, int cnt){
    for (int i=0; i < dungeons.length; i++) {
      if (!check[i] && dungeons[i][0] <= tired) {
        check[i] = true;
        dfs(tired-dungeons[i][1], dungeons, cnt+1);
        check[i] = false;
      }
    }
    ans = Math.max(ans, cnt);
  }
}
```

<mark>LV.2 전력망을 둘로 나누기</mark>
```
class Solution {
  int N, min;
  int[][] map;
  int[] vst;

  int dfs(int n){
    vst[n] = 1;
    int child = 1;
    for(int i = 1; i <= N; i++) {
      if(vst[i] == 0 && map[n][i] == 1) {
        child += dfs(i);
      }
    }
    min = Math.min(min, Math.abs(child - (N - child)));
    return child;
  }

  public int solution(int n, int[][] wires) {
    N = n;
    min = n;
    map = new int[n+1][n+1];
    vst = new int[n+1];
    for(int[] wire : wires) {
      int a = wire[0], b = wire[1];
      map[a][b] = map[b][a] = 1;
    }
    dfs(1);
    return min;
  }
}
```

<mark>LV.2 모음사전</mark>
```
import java.util.*;
class Solution {
  List<String> list = new ArrayList<>();
  
  void dfs(String str, int len) {
    if(len > 5) return;
    list.add(str);
    for(int i = 0; i < 5; i++) dfs(str + "AEIOU".charAt(i), len + 1);
  }
  
  public int solution(String word) {
    dfs("", 0);
    return list.indexOf(word);
  }
}
```
DFS를 이용한 완전탐색 방법입니다.  
찾는 word 값 이후의 값도 탐색되지 않게 개선하면 좋을 것 같습니다.

### 탐욕법(Greedy) 문제 풀이
<mark>LV.1 체육복</mark>
```
class Solution {
  public int solution(int n, int[] lost, int[] reserve) {
    int[] people = new int[n];
    int answer = n;

    for (int l : lost) 
      people[l-1]--;
    for (int r : reserve) 
      people[r-1]++;

    for (int i = 0; i < people.length; i++) {
      if(people[i] == -1) {
        if(i-1>=0 && people[i-1] == 1) {
          people[i]++;
          people[i-1]--;
        }else if(i+1< people.length && people[i+1] == 1) {
          people[i]++;
          people[i+1]--;
        }else 
          answer--;
      }
    }
    return answer;
  }
}
```
배열 크기를 n+2로 선언하면  0과 마지막 인덱스를 더 잡을 수 있어서 if문 조건 하나씩 없앨 수 있습니다.

<mark>LV.2 조이스틱</mark>
```
class Solution {
  public int solution(String name) {
    int answer = 0;
    int[] diff={0,1,2,3,4,5,6,7,8,9,10,11,12,13,12,11,10,9,8,7,6,5,4,3,2,1};
    for(char c:name.toCharArray())
      answer+=diff[c-'A'];

    int length=name.length();
    int min=length-1;

    for(int i=0;i<length;i++){
      int next=i+1;
      while(next<length && name.charAt(next)=='A'){
        next++;
      }      

      min=Math.min(min,i+length-next+Math.min(i,length-next));
    }

    return answer+min;
  }
}
```

<mark>LV.2 큰 수 만들기</mark>
```
import java.util.Stack;

class Solution {
  public String solution(String number, int k) {
    char[] result = new char[number.length() - k];
    Stack<Character> stack = new Stack<>();

    for (int i=0; i<number.length(); i++) {
      char c = number.charAt(i);
      while (!stack.isEmpty() && stack.peek() < c && k-- > 0) {
        stack.pop();
      }
      stack.push(c);
    }
    for (int i=0; i<result.length; i++) {
      result[i] = stack.get(i);
    }
    return new String(result);
  }
}
```

<mark>LV.2 구명보트</mark>
```
import java.util.Arrays;

class Solution {
  public int solution(int[] people, int limit) {
    Arrays.sort(people);
    int i = 0, j = people.length - 1;
    for (; i < j; --j) {
      if (people[i] + people[j] <= limit)
        ++i;
    }
    return people.length - i;
  }
}
```

<mark>LV.3 섬 연결하기</mark>
```
import java.util.Arrays;

class Solution {
  public int solution(int n, int[][] costs) {
    int sum = 0;
    int[] island = new int[n];

    for(int i = 0; i < n; i++)
      island[i] = i;

    Arrays.sort(costs, (a, b) -> Integer.compare(a[2], b[2]));

    for(int i = 0; i < costs.length; i++) {
      if(find(island, costs[i][0]) != find(island, costs[i][1])) {
        unite(island, costs[i][0], costs[i][1]);
        sum += costs[i][2];
      }
    }

    return sum;
  }

  private int find(int[] island, int x) {
    if(island[x]== x)
      return x;

    return find(island, island[x]);
  }

  private void unite(int[] island, int x, int y) {
    int a = find(island, x);
    int b = find(island, y);
    island[a] = b;
  }
}
```

<mark>LV.3 단속카메라</mark>
```
import java.util.Arrays;

class Solution {
  public int solution(int[][] routes) {
    Arrays.sort(routes, (a, b) -> Integer.compare(a[1], b[1]));
    int ans = 0;
    int last_camera = Integer.MIN_VALUE;
    for (int[] a : routes) {
      if (last_camera < a[0]) {
        ++ans;
        last_camera = a[1];
      }
    }
    return ans;
  }
}
```

### 동적계획법(Dynamic Programming) 문제 풀이
<mark>LV.3 N으로 표현</mark>
```
import java.util.HashSet;
import java.util.Set;

class Solution {
  public int solution(int N, int number) {
    int answer = -1;
    Set<Integer>[] setArr = new Set[9];
    int t = N;

    for(int i = 1; i < 9; i++) {
      setArr[i] = new HashSet<>();
      setArr[i].add(t);
      t = t * 10 + N;
    }

    for(int i = 1; i < 9; i++) {
      for(int j = 1; j < i; j++) {
        for(Integer a : setArr[j]) {
          for(Integer b : setArr[i - j]) {
            setArr[i].add(a + b);
            setArr[i].add(a - b);
            setArr[i].add(b - a);
            setArr[i].add(a * b);
            if(b != 0) {
              setArr[i].add(a / b);
            }
            if(a != 0) {
              setArr[i].add(b / a);
            }
          }
        }
      }
    }

    for(int i = 1; i < 9; i++) {
      if(setArr[i].contains(number)) {
        answer = i;
        break;
      }
    }

    return answer;
  }
}
```

<mark>LV.3 정수 삼각형</mark>
```
import java.util.*;

class Solution {
  public int solution(int[][] triangle) {
    for (int i = 1; i < triangle.length; i++) {
      triangle[i][0] += triangle[i-1][0];
      triangle[i][i] += triangle[i-1][i-1];

      for (int j = 1; j < i; j++) 
        triangle[i][j] += Math.max(triangle[i-1][j-1], triangle[i-1][j]);
    }

    return Arrays.stream(triangle[triangle.length-1]).max().getAsInt();
  }
}
```

<mark>LV.3 등굣길</mark>
```
class Solution {
  public int solution(int m, int n, int[][] puddles) {
    int[][] dp = new int[m+1][n+1];

    for(int i=0;i<puddles.length;i++){
        dp[puddles[i][0]][puddles[i][1]]=-1;
    }

    dp[1][1]=1; 
    for(int i=1;i<=m;i++){
      for(int j=1;j<=n;j++){
        if(dp[i][j]==-1){
          dp[i][j]=0;
          continue;
        }
        if(i!=1) dp[i][j]+=dp[i-1][j]%1000000007;
        if(j!=1) dp[i][j]+=dp[i][j-1]%1000000007;
      }
    }

    return dp[m][n]%1000000007;
  }
}
```

<mark>LV.4 사칙연산</mark>
```
class Solution {
  int[][] minMem = new int[210][210];
  boolean[][] minVisited = new boolean[210][210];
  int[][] maxMem = new int[210][210];
  boolean[][] maxVisited = new boolean[210][210];

  public int solution(String arr[]) {
    return computeMax(arr, 0, arr.length-1);
  }

  int computeMax(String[] arr, int s, int e) {
    if(s == e) return Integer.parseInt(arr[s]);
    if(maxVisited[s][e]) return maxMem[s][e];
    int r = Integer.MIN_VALUE;
    for(int i = s; i <= e-2; i += 2) {
      if(arr[i+1].equals("+")) {
        r = Math.max(r, computeMax(arr, s, i) + computeMax(arr, i+2, e));
      } else {
        r = Math.max(r, computeMax(arr, s, i) - computeMin(arr, i+2, e));
      }
    }
    maxVisited[s][e] = true;
    maxMem[s][e] = r;
    return r;
  }

  int computeMin(String[] arr, int s, int e) {
    if(s == e) return Integer.parseInt(arr[s]);
    if(minVisited[s][e]) return minMem[s][e];
    int r = Integer.MAX_VALUE;
    for(int i = s; i <= e-2; i += 2) {
      if(arr[i+1].equals("+")) {
        r = Math.min(r, computeMin(arr, s, i) + computeMin(arr, i+2, e));
      } else {
        r = Math.min(r, computeMin(arr, s, i) - computeMax(arr, i+2, e));
      }
    }
    minVisited[s][e] = true;
    minMem[s][e] = r;
    return r;
  }
}
```

<mark>LV.4 도둑질</mark>
```
class Solution {
  public int solution(int[] money) {        
    int[][] pick = new int[2][money.length];

    pick[0][0] = money[0];
    pick[0][1] = money[0];
    pick[1][0] = 0;
    pick[1][1] = money[1];

    for(int i=2; i<money.length; i++) {
      pick[0][i] = Math.max(pick[0][i-2] + money[i], pick[0][i-1]);
      pick[1][i] = Math.max(pick[1][i-2] + money[i], pick[1][i-1]);
    }

    return Math.max(pick[0][pick[0].length-2], pick[1][pick[1].length-1]);
  }
}
```

### 깊이/너비 우선 탐색(DFS/BFS) 문제 풀이
<mark>LV.2 타겟 넘버</mark>
```
class Solution {
  public int solution(int[] numbers, int target) {
    int answer = 0;
    answer = dfs(numbers, 0, 0, target);
    return answer;
  }

  int dfs(int[] numbers, int n, int sum, int target) {
    if(n == numbers.length) {
      if(sum == target) {
        return 1;
      }
      return 0;
    }

    return dfs(numbers, n + 1, sum + numbers[n], target) + dfs(numbers, n + 1, sum - numbers[n], target);
  }
}
```

<mark>LV.3 네트워크</mark>
```
class Solution {
  public int solution(int n, int[][] computers) {
    int answer = 0;
    boolean[] chk = new boolean[n];
    for(int i = 0; i < n; i++) {
      if(!chk[i]) {
        dfs(computers, chk, i);
        answer++;
      }
    }
    return answer;
  }

  void dfs(int[][] computers, boolean[] chk, int start) {
    chk[start] = true;
    for(int i = 0; i < computers.length; i++) {
      if(computers[start][i] == 1 && !chk[i]) {
        dfs(computers, chk, i);
      }
    }
  }
}
```

<mark>LV.2 게임 맵 최단거리</mark>
```
import java.util.*;

class Solution {
  public int solution(int[][] maps) {
    int rows = maps.length;
    int cols = maps[0].length;

    int[][] directions = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; // 상하좌우

    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{0, 0, 1}); // 시작 위치와 거리

    while (!queue.isEmpty()) {
      int[] current = queue.poll();
      int row = current[0];
      int col = current[1];
      int distance = current[2];

      if (row == rows - 1 && col == cols - 1) {
        return distance; // 목적지에 도달한 경우 최단거리 반환
      }

      for (int[] dir : directions) {
        int newRow = row + dir[0];
        int newCol = col + dir[1];

        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && maps[newRow][newCol] == 1) {
          maps[newRow][newCol] = 0; // 방문한 위치는 재방문하지 않도록 표시
          queue.offer(new int[]{newRow, newCol, distance + 1});
        }
      }
    }

    return -1; // 목적지에 도달하지 못한 경우
  }
}
```

<mark>LV.3 단어 변환</mark>
```
import java.util.LinkedList;
import java.util.Queue;

class Solution {

  static class Node {
    String next;
    int edge;

    public Node(String next, int edge) {
      this.next = next;
      this.edge = edge;
    }
  }

  public int solution(String begin, String target, String[] words) {
    int n = words.length, ans = 0;

    Queue<Node> q = new LinkedList<>();

    boolean[] visit = new boolean[n];
    q.add(new Node(begin, 0));

    while(!q.isEmpty()) {
      Node cur = q.poll();
      if (cur.next.equals(target)) {
        ans = cur.edge;
        break;
      }

      for (int i=0; i<n; i++) {
        if (!visit[i] && isNext(cur.next, words[i])) {
          visit[i] = true;
          q.add(new Node(words[i], cur.edge + 1));
        }
      }
    }

    return ans;
  }

  static boolean isNext(String cur, String n) {
    int cnt = 0;
    for (int i=0; i<n.length(); i++) {
      if (cur.charAt(i) != n.charAt(i)) {
        if (++ cnt > 1) return false;
      }
    }

    return true;
  }    
}
```

<mark>LV.3 아이템 줍기</mark>
```
import java.util.*;

class Solution {
  int[][] wh = { {0, 1, 0, -1}, {1, 0, -1, 0} };
  public int solution(int[][] rectangle, int characterX, int characterY, int itemX, int itemY) {
    int answer = 0;

    // 모든 값을 두 배로
    characterX *= 2;
    characterY *= 2;
    itemX *= 2;
    itemY *= 2;

    for(int i = 0; i < rectangle.length; i++) {
      var rec = rectangle[i];
      rectangle[i] = new int[] { rec[0] * 2, rec[1] * 2, rec[2] * 2, rec[3] * 2};
    }

    boolean[][] map = new boolean[102][102], vst = new boolean[102][102];

    for(int[] rec : rectangle) {
      for(int i = rec[0]; i <= rec[2]; i++) {
        for(int j = rec[1]; j <= rec[3]; j++) {
          map[i][j] = true;
        }
      }
    }

    // 테두리만 남겨둔다.
    Queue<int[]> q = new LinkedList<>();

    for(int i = 1; i <= 100; i++) {
      for(int j = 1; j <= 100; j++) {
        int inner = 0;
        for(int[] rec : rectangle) {
          if(rec[0] < i && i < rec[2] && rec[1] < j && j < rec[3]) inner++;
        }
        if(inner != 0) q.add(new int[] { i, j });
      }
    }

    for(int[] p : q) map[p[0]][p[1]] = false;

    // 이후는 일반 bfs
    q = new LinkedList<>();
    q.add(new int[] { characterX, characterY, 0 });
    vst[characterX][characterY] = true;

    while(!q.isEmpty()) {
      int[] p = q.poll();
      if(p[0] == itemX && p[1] == itemY) answer = p[2] / 2;
      else {
        for(int i = 0; i < 4; i++) {
            int x = p[0] + wh[0][i];
          int y = p[1] + wh[1][i];
          if(0 <= x && 0 <= y && x < 102 && y < 102 && !vst[x][y] && map[x][y]) {
            q.add(new int[] {x, y, p[2] + 1});
            vst[x][y] = true;
          }
        }
      }
    }

    return answer;
  }
}
```

<mark>LV.3 여행경로</mark>
```
import java.util.*;

class Solution {
  List<Stack<String>> result;
  String[][] tickets;

  public String[] solution(String[][] tickets) {
    result = new ArrayList<>();
    this.tickets = tickets;

    boolean[] visited = new boolean[tickets.length];
    Stack<String> st = new Stack<>();
    st.push("ICN");

    dfs(visited, st, 0);

    if (result.size() > 1) {
      Collections.sort(result, new Comparator<Stack<String>>() {
        @Override
        public int compare(Stack<String> o1, Stack<String> o2) {
          for (int i = 0; i < o1.size(); i++) {
            String s1 = o1.get(i);
            String s2 = o2.get(i);

            if (!s1.equals(s2)) {
              return s1.compareTo(s2);
            }
          }

          return 0;
        }
      });
    }

    Stack<String> res = result.remove(0);
    String[] answer = new String[res.size()];

    for (int i = 0; i < answer.length; i++) {
      answer[i] = res.get(i);
    }

    return answer;
  }

  public void dfs(boolean[] visited, Stack<String> st, int len) {
    if (len == tickets.length) {
      Stack<String> res = new Stack<>();
      for (String s : st) {
        res.push(s);
      }

      result.add(res);
      return;
    }

    String arrive = st.peek();

    for (int i = 0; i < tickets.length; i++) {
      String[] tic = tickets[i];

      if (!visited[i] && arrive.equals(tic[0])) {
        st.push(tic[1]);
        visited[i] = true;

        dfs(visited, st, len + 1);

        visited[i] = false;
        st.pop();
      }
    }
  }
}
```

<mark>LV.3 퍼즐 조각 채우기</mark>
```
import java.util.*;

class Solution {
  public class Node {
      int x, y;

      Node(int x, int y) {
          this.x = x;
          this.y = y;
      }
  }
  public ArrayList<String> emptyList = new ArrayList<>();
  public int N;
  public int[] dx = {0, 0, -1, 1};
  public int[] dy = {-1, 1, 0, 0};

  public int solution(int[][] game_board, int[][] table) {
      N = game_board.length;
      int answer = 0;

      for(int i = 0; i < N; i++) {
          for(int j = 0; j < N ; j++) {
              if(game_board[i][j] == 0) {
                  emptyList.add(bfs(game_board, i, j, 0));
              }
          }
      }

      for(int i = 0; i < N; i++) {
          for(int j = 0; j < N ; j++) {
              if(table[i][j] == 1) {
                  answer += find(bfs(table, i, j, 1));
              }
          }
      }

      return answer;
  }

  public int find(String s) {
      int point = 0;

      for(int i = 0; i < s.length(); i++) {
          if(s.charAt(i) == '1') point++;
      }

      for(int i = 0; i < emptyList.size(); i++) {
          String str = emptyList.get(i);

          for(int j = 0; j < 4; j++) {
              str = rotate(str);
              // System.out.println(str);
              if(s.equals(str)) {
                  emptyList.remove(i);
                  return point;
              }
          }
      }

      return 0;
  }

  public String rotate(String s) {
    String str = "";
    int x = 0;
    int y = 0;

    for(int i = 0; i < s.length(); i++) {
      if(x == 0) {
        if(s.charAt(i) != ' ') {
          y++;
        }
      }
      if(s.charAt(i) == ' ') {
        x++;
      }
    }

    char[][] arr = new char[x][y];
    StringTokenizer st = new StringTokenizer(s);

    for(int i = 0; i < x; i++) {
      arr[i] = st.nextToken().toCharArray();
    }

    for(int j = 0; j < y; j++) {
      for(int i = x - 1; i >= 0; i--) {
        str += arr[i][j];
      }
      str += " ";
    }

    return str;
  }

  public String bfs(int[][] arr, int i, int j, int mode) {
    // mode 0 : game_board, mode 1 : table
    String s = "";
    ArrayDeque<Node> q = new ArrayDeque<>();
    boolean[][] tmp = new boolean[N][N];

    int x_min = i;
    int x_max = i;
    int y_min = j;
    int y_max = j;

    tmp[i][j] = true;
    arr[i][j] = (mode + 1) % 2;
    q.add(new Node(i, j));

    while(!q.isEmpty()) {
      Node cur = q.poll();
      int x = cur.x;
      int y = cur.y;

      x_min = Math.min(x_min, x);
      x_max = Math.max(x_max, x);
      y_min = Math.min(y_min, y);
      y_max = Math.max(y_max, y);

      for(int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];

        if(!isBoundary(nx, ny)) continue;

        if(arr[nx][ny] == mode) {
          tmp[nx][ny] = true;
          arr[nx][ny] = (mode + 1) % 2;
          q.add(new Node(nx, ny));
        }
      }
    }

    for(int x = x_min; x <= x_max; x++) {
      for(int y = y_min; y <= y_max; y++) {
        s += tmp[x][y] ? "1" : "0";
      }
      s += " ";
    }

    return s;
  }

  public boolean isBoundary(int x, int y) {
    return x >= 0 && x < N && y >= 0 && y < N;
  }
}
```

### 이분탐색 문제 풀이
<mark>LV.3 입국심사</mark>
```
import java.util.Arrays;
class Solution {
  public long solution(int n, int[] times) {
    long answer = 0;
    Arrays.sort(times);
    long left = 0;
    long right = times[times.length-1] * (long)n; //모든 사람이 가장 느리게 심사받음
    
    while(left <= right) {
      long mid = (left + right) / 2;
      long complete = 0;
      for (int i = 0; i < times.length; i++)
        complete += mid / times[i];
      if (complete < n) // 해당 시간에는 모든 사람이 검사받을 수 없다.
        left = mid + 1;
      else {
        right = mid - 1;
        answer = mid; // 모두 검사받았으나, 더 최솟값이 있을 수 있다.
      }
    }  
    return answer;
  }
}
```

<mark>LV.4 징검다리</mark>
```
import java.util.*;

class Solution {
  public int solution(int distance, int[] rocks, int n) {
    int answer = 0;

    Arrays.sort(rocks);
    
    int left = 1;
    int right = distance;

    while(left <= right){
      int mid = (left + right)/2;
      if(getRemovedRockCnt(rocks, mid, distance) <= n){
        answer = mid;
        left = mid + 1;
      } else {
        right = mid - 1; 
      }
    }
    
    return answer;
  }
  
  public int getRemovedRockCnt(int[] rocks, int mid, int distance){
    // mid가 바위(지점) 간 최소 거리가 되어야 함
    // 그렇게 하기 위해 제거 해야할 바위의 개수를 리턴한다. 
    int before = 0; 
    int end = distance;
    
    int removeCnt = 0;

    for(int i = 0; i < rocks.length; i++){
      if(rocks[i] - before < mid) {
        removeCnt++;
        continue;
      }

      before = rocks[i];
    }

    if(end - before < mid) removeCnt++;

    return removeCnt;
  }
}
```

### 그래프 문제 풀이
<mark>LV.3 가장 먼 노드</mark>
```
import java.util.ArrayList;

class Solution {
  public int solution(int n, int[][] edge) {
    ArrayList<Integer>[] path = new ArrayList[n];
    ArrayList<Integer> bfs = new ArrayList<Integer>();
    int answer = 0;
    int[] dist = new int[n];
    dist[0] = 1;
    int max = 0;

    for(int i = 0; i < edge.length; i++) {
      int num1 = edge[i][0] - 1;
      int num2 = edge[i][1] - 1;

      if(path[num1] == null)
        path[num1] = new ArrayList<Integer>();

      if(path[num2] == null)
        path[num2] = new ArrayList<Integer>();

      path[num1].add(num2);
      path[num2].add(num1);
    }

    bfs.add(0);

    while(!bfs.isEmpty()) {
      int idx = bfs.get(0);
      bfs.remove(0);
      while(!path[idx].isEmpty()) {
        int num = path[idx].get(0);
        path[idx].remove(0);
        bfs.add(num);

        if(dist[num] == 0) {
          dist[num] = dist[idx] + 1;
          max = dist[num];
        }
      }
    }

    for(int i = 0; i < n; i++) {
      if(dist[i] == max)
        answer++;
    }

    return answer;
  }
}
```

<mark>LV.3 순위</mark>
```
class Solution {
  public int solution(int n, int[][] results) {
    int answer = 0;

    boolean[][] chk = new boolean[n + 1][n + 1];

    for(int i = 0; i < results.length; i++) {
      chk[results[i][0]][results[i][1]] = true;
    }

    for(int k = 1; k < n + 1; k++) {
      for(int i = 1; i < n + 1; i++) {
        for(int j = 1; j < n + 1; j++) {
          if(i != j && chk[i][k] && chk[k][j]) {
            chk[i][j] = true;
          }
        }
      }
    }

    for(int i = 1; i < n + 1; i++) {
      boolean pass = true;

      for(int j = 1; j < n + 1; j++) {
        if(i != j && !(chk[i][j] || chk[j][i])) {
          pass = false;
          break;
        }
      }

      if(pass) {
        answer++;
      }
    }

    return answer;
  }
}
```

<mark>LV.5 방의 개수</mark>
```
import java.util.HashSet;
import java.util.Set;

class Solution {
  public int solution(int[] arrows) {
      int answer = 0;
      Set<String> lineSet = new HashSet<String>();
      Set<String> pointSet = new HashSet<String>();
      int x = 0;
      int y = 0;
      pointSet.add("" + x+"|"+y);
      for (int i = 0; i < arrows.length; i++) {
        for(int j = 0; j < 2; j++){
          int vect = arrows[i];
          String start = ""+ x+"|"+y;

          if(vect<=1 || vect==7) y++;
          if(1<=vect && vect<=3) x++;
          if(3<=vect && vect<=5) y--;
          if(5<=vect && vect<=7) x--;

          String point = "" + x+"|"+y;
          String normalLine = start +"|" + point; 
          String backLine =  point + "|" + start; 

          if(pointSet.contains(point)){
            if(!lineSet.contains(normalLine)){
              answer++;
            }
          }

          pointSet.add(point);
          lineSet.add(normalLine);
          lineSet.add(backLine);
        }
      }

      return answer;
  }
}
```
