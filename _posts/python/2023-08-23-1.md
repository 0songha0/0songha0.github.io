---
title: "프로그래머스 코딩테스트 고득점 Kit 47문제 풀이 (작성중)"
excerpt: ""

categories:
  - 파이썬 / 코딩테스트
tags:
  - []

permalink: /python/2023-08-23-1

toc: true
toc_sticky: true
 
date: 2023-08-23
last_modified_at: 2023-08-23
---

파이썬 입문자인 저의 풀이와 본받을 코드를 모아서 복습하는 글입니다.

<mark>대기업 코테 난이도</mark>  
보통 프로그래머스 LV.3 미만, 코드포스 블루 레벨이라고 합니다.

---

## 프로그래머스 코딩테스트 고득점 Kit 47문제

<https://school.programmers.co.kr/learn/challenges?tab=algorithm_practice_kit>{: target="_blank"}  

<mark>난이도 낮은 순서</mark>  
정렬, 스택/큐, 완전탐색 > 힙, 해시, 깊이/너비 우선 탐색(DFS/BFS), 탐욕법(Greedy) > 동적계획법(DP), 이분탐색, 그래프  
코테 준비 기간이 여유롭다면, 쉬운 유형부터 천천히 풀어나가는 것이 좋습니다.

<mark>출제 빈도 높은 순서</mark>  
깊이/너비 우선 탐색(DFS/BFS), 완전탐색, 정렬, 해시 > 스택/큐, 힙 > 동적계획법(DP), 그래프, 탐욕법(Greedy), 이분탐색  
코테를 준비할 시간이 없다면, 가장 출제 빈도가 높은 DFS/BFS를 우선 공부해야 합니다.

<mark>효율적인 문제 풀이 방법</mark>
1. 최대한 문제의 요구사항을 이해하며 풀어봅니다.
2. 30분 넘게 문제를 풀지 못하면, 검색하여 답안을 확인합니다.
3. 이해 안되는 코드는 디버깅하거나 코드 설명을 보고 완벽하게 이해합니다.
4. 시간이 지난 후, 모든 코드를 지우고 다시 풀어봅니다.
5. 코드를 완벽하게 외워서 구현할 수 있을 때까지 반복하여 풉니다.

### 해시 문제 풀이
<mark>폰켓몬</mark>
```
import java.util.HashSet;

class Solution {
  public int solution(int[] nums) {

    HashSet<Integer> hs = new HashSet<>();

    for(int i =0; i<nums.length;i++) {
      hs.add(nums[i]);
    }

    if(hs.size()>nums.length/2)
      return nums.length/2;

    return hs.size();
  }
}
```
HashSet은 중복된 요소를 없애줍니다.

<mark>완주하지 못한 선수</mark>
```
import java.util.HashMap;

class Solution {
  public String solution(String[] participant, String[] completion) {
    String answer = "";
    HashMap<String, Integer> hm = new HashMap<>();
    for (String player : participant) hm.put(player, hm.getOrDefault(player, 0) + 1);
    for (String player : completion) hm.put(player, hm.get(player) - 1);

    for (String key : hm.keySet()) {
      if (hm.get(key) != 0){
        answer = key;
      }
    }

    return answer;
  }
}
```

<mark>전화번호 목록</mark>
```
import java.util.HashMap;

class Solution {
  public boolean solution(String[] phoneBook) {
    boolean answer = true;

    HashMap<String, Integer> map = new HashMap<>();

    for(int i = 0; i < phoneBook.length; i++) {
      map.put(phoneBook[i], i);
    }

    for(int i = 0; i < phoneBook.length; i++) {
      for(int j = 0; j < phoneBook[i].length(); j++) {
        if(map.containsKey(phoneBook[i].substring(0,j))) {
          answer = false;
          return answer;
        }
      }
    }

    return answer;
  }
}
```

<mark>의상</mark>
```
import java.util.HashMap;
import java.util.Iterator;

class Solution {
  public int solution(String[][] clothes) {
    int answer = 1;
    HashMap<String, Integer> map = new HashMap<>();
    
    for(int i = 0; i < clothes.length; i++){
      String key = clothes[i][1];
      if(!map.containsKey(key)) {
        map.put(key, 1);
      } else {
        map.put(key, map.get(key) + 1);
      }
    }
    
    Iterator<Integer> it = map.values().iterator();
    
    while(it.hasNext()) {
      answer *= it.next().intValue()+1;
    }
    
    return answer-1;
  }
}
```

<mark>베스트앨범</mark>
```
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.Collections;

class Solution {
  public int[] solution(String[] genres, int[] plays) {
    // 장르, 곡 정보
    HashMap<String, Object> genresMap = new HashMap<String, Object>();
    // 장르, 총 장르 재생수
    HashMap<String, Integer> playMap = new HashMap<String, Integer>();
    ArrayList<Integer> resultAL = new ArrayList<Integer>();

    for(int i = 0; i < genres.length; i++){
      String key = genres[i];
      // 곡 정보 : 곡 고유번호, 재생횟수
      HashMap<Integer, Integer> infoMap;

      if(genresMap.containsKey(key)){
        infoMap = (HashMap<Integer, Integer>)genresMap.get(key);
      } else {
        infoMap = new HashMap<Integer, Integer>();
      }

      infoMap.put(i, plays[i]);
      genresMap.put(key, infoMap);

      // 재생수
      if(playMap.containsKey(key)){
        playMap.put(key, playMap.get(key) + plays[i]);
      } else {
        playMap.put(key, plays[i]);
      }
    }

    int mCnt = 0;
    Iterator it = sortByValue(playMap).iterator();

    while(it.hasNext()){
      String key = (String)it.next();
      Iterator indexIt = sortByValue((HashMap<Integer, Integer>)genresMap.get(key)).iterator();
      int playsCnt = 0;

      while(indexIt.hasNext()){
        resultAL.add((int)indexIt.next());
        mCnt++;
        playsCnt++;
        if(playsCnt > 1) break;
      }
    }

    int[] answer = new int[resultAL.size()];

    for(int i = 0; i < resultAL.size(); i++){
      answer[i] = resultAL.get(i).intValue();
    }

    return answer;
  }

  private ArrayList sortByValue(final Map map){
    ArrayList<Object> keyList = new ArrayList();
    keyList.addAll(map.keySet());

    Collections.sort(keyList, new Comparator(){
      public int compare(Object o1, Object o2){
        Object v1 = map.get(o1);
        Object v2 = map.get(o2);

        return ((Comparable) v2).compareTo(v1);
      }
    });

    return keyList;
  }
}
```

### 스택/큐 문제 풀이
<mark>같은 숫자는 싫어</mark>
```
import java.util.*;

public class Solution {
  public int[] solution(int []arr) {
    List<Integer> list = new ArrayList<Integer>();
    list.add(arr[0]);

    for (int i = 1; i < arr.length; i++) {
      if (arr[i] != arr[i - 1])
        list.add(arr[i]);
    }

    int[] answer = new int[list.size()];

    for (int i = 0; i < list.size(); i++)
      answer[i] = list.get(i);

    return answer;
  }
}
```

<mark>기능개발</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] progresses, int[] speeds) {
    Queue<Integer> q = new LinkedList<>();
    List<Integer> answerList = new ArrayList<>();

    for (int i = 0; i < speeds.length; i++) {
      double remain = (100 - progresses[i]) / (double) speeds[i];
      int date = (int) Math.ceil(remain);

      if (!q.isEmpty() && q.peek() < date) {
        answerList.add(q.size());
        q.clear();
      }

      q.offer(date);
    }

    answerList.add(q.size());

    int[] answer = new int[answerList.size()];

    for (int i = 0; i < answer.length; i++) {
      answer[i] = answerList.get(i);
    }

    return answer;
  }
}
```

<mark>올바른 괄호</mark>
```
class Solution {
  boolean solution(String s) {
    boolean answer = false;
    int count = 0;
    for(int i = 0; i < s.length(); i++) {

      if(s.charAt(i) == '('){
        count++;
      }

      if(s.charAt(i) == ')'){
        count--;
      }

      if(count < 0){
        break;
      }
    }

    if(count == 0){
      answer = true;
    }

    return answer;
  }
}
```

<mark>프로세스</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] priorities, int location) {
    int answer = 0;
    int l = location;

    Queue<Integer> que = new LinkedList<Integer>();
    for(int i : priorities){
      que.add(i);
    }

    Arrays.sort(priorities);
    int size = priorities.length-1;

    while(!que.isEmpty()){
      Integer i = que.poll();
      if(i == priorities[size - answer]){
        answer++;
        l--;
        if(l <0)
          break;
      }else{
        que.add(i);
        l--;
        if(l<0)
          l=que.size()-1;
      }
    }

    return answer;
  }
}
```

<mark>다리를 지나는 트럭</mark>
```
import java.util.*;

class Solution {
  class Truck {
    int weight;
    int move;

    public Truck(int weight) {
      this.weight = weight;
      this.move = 1;
    }

    public void moving() {
      move++;
    }
  }

  public int solution(int bridgeLength, int weight, int[] truckWeights) {
    Queue<Truck> waitQ = new LinkedList<>();
    Queue<Truck> moveQ = new LinkedList<>();

    for (int t : truckWeights) {
      waitQ.offer(new Truck(t));
    }

    int answer = 0;
    int curWeight = 0;

    while (!waitQ.isEmpty() || !moveQ.isEmpty()) {
      answer++;

      if (moveQ.isEmpty()) {
        Truck t = waitQ.poll();
        curWeight += t.weight;
        moveQ.offer(t);
        continue;
      }

      for (Truck t : moveQ) {
        t.moving();
      }

      if (moveQ.peek().move > bridgeLength) {
        Truck t = moveQ.poll();
        curWeight -= t.weight;
      }

      if (!waitQ.isEmpty() && curWeight + waitQ.peek().weight <= weight) {
        Truck t = waitQ.poll();
        curWeight += t.weight;
        moveQ.offer(t);
      }
    }

    return answer;
  }
}

```

### 힙(Heap) 문제 풀이
<mark>더 맵게</mark>

<mark>디스크 컨트롤러</mark>

<mark>이중우선순위큐</mark>

### 정렬 문제 풀이
<mark>K번째수</mark>
```
import java.util.*;

class Solution {
    public int[] solution(int[] array, int[][] commands) {
        int[] answer = new int[commands.length];
        
        for(int i = 0; i < commands.length; i++) {
            // 이차원 배열에서 배열 추출
            int[] command = Arrays.copyOfRange(array, commands[i][0]-1, commands[i][1]);
            
            // 오름차순 정렬
            Arrays.sort(command);
            
            // K번째 수
            answer[i] = command[commands[i][2]-1];
            
        }
        
        return answer;
    }
}
```
Arrays.toString, Arrays.deepToString 함수로 배열, 이차원배열 출력이 가능합니다.

내림차순 정렬은 Arrays.sort(command, Collections.reverseOrder()); 으로 할 수 있습니다.

<mark>가장 큰 수</mark>
```
import java.util.*;

class Solution {
    public String solution(int[] numbers) {
        ArrayList<String> strList = new ArrayList<String>();
        
        // 각 int 원소를 String으로 변환
        for (int i = 0; i < numbers.length; i++) {
            strList.add(String.valueOf(numbers[i]));
        }
        
        // 앞뒤 원소 문자열 조합을 비교하며 오름차순 정렬
        Collections.sort(strList, (o1, o2) -> (o2 + o1).compareTo(o1 + o2));
        
        // 결과 String 연결
        StringBuilder sb = new StringBuilder();
        
        for (String str : strList) {
            sb.append(str);
        }
        
        String answer = sb.toString();
        
        // 원소가 [0, 0, 0]이면 0 반환, 외에는 그대로 반환
        return answer.charAt(0) == '0'? "0" : answer;
    }
}
```
compareTo 함수는 현재 객체가 다른 객체보다 작으면 크면 1, 음수, 같으면 0을 반환합니다.  
(o2 + o1).compareTo(o1 + o2)은 반환값이 1이면 순서를 바꿔서, 내림차순 정렬됩니다.  
(o1 + o2).compareTo(o2 + o1)은 반환값이 1이면 순서를 바꿔서, 오름차순 정렬됩니다.

문자열을 반복하여 더할 때 String += 대신 StringBuilder를 사용하면 메모리 효율적입니다.

answer.charAt(0) == '0' 대신 answer.startsWith("0")를 사용해도 됩니다.

<mark>H-Index</mark>
```
def solution(citations):
  citations.sort(reverse=True)
  return max(map(min, enumerate(citations, start=1)))
```
start=1 옵션으로 enumerate의 index를 1부터 시작합니다.  

```
def solution(citations):
  citations.sort()
  
  length = len(citations)
  
  for i in range(length):
      if citations[i] >= length-i:
          return length-i
  
  return 0
```
시간복잡도가 더 효율적인 코드입니다.  
length - i는 인덱스 값과 같거나 큰 수의 개수입니다.

### 완전탐색 문제 풀이
<mark>최소직사각형</mark>

<mark>모의고사</mark>

<mark>소수 찾기</mark>

<mark>카펫</mark>

<mark>피로도</mark>

<mark>전력망을 둘로 나누기</mark>

<mark>모음사전</mark>

### 탐욕법(Greedy) 문제 풀이
<mark>체육복</mark>

<mark>조이스틱</mark>

<mark>큰 수 만들기</mark>

<mark>구명보트</mark>

<mark>섬 연결하기</mark>

<mark>단속카메라</mark>

### 동적계획법(Dynamic Programming) 문제 풀이
<mark>N으로 표현</mark>

<mark>정수 삼각형</mark>

<mark>사칙연산</mark>

<mark>등굣길</mark>

<mark>도둑질</mark>

### 깊이/너비 우선 탐색(DFS/BFS) 문제 풀이
<mark>타겟 넘버</mark>

<mark>네트워크</mark>

<mark>게임 맵 최단거리</mark>

<mark>단어 변환</mark>

<mark>아이템 줍기</mark>

<mark>여행경로</mark>

<mark>퍼즐 조각 채우기</mark>

### 이분탐색 문제 풀이
<mark>입국심사</mark>

<mark>징검다리</mark>

### 그래프 문제 풀이
<mark>가장 먼 노드</mark>

<mark>순위</mark>

<mark>방의 개수</mark>