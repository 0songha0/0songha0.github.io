---
title: "프로그래머스 코딩테스트 입문 Lv.0 100문제 Java 풀이 (작성중)"
excerpt: ""

categories:
  - 파이썬 / 코딩테스트
tags:
  - []

permalink: /python/2024-05-21-2

toc: true
toc_sticky: true
 
date: 2024-05-21
last_modified_at: 2024-05-21
---

## 프로그래머스 코딩테스트 입문 Lv.0 100문제

<https://school.programmers.co.kr/learn/challenges/beginner?order=recent>{: target="_blank"}  
입문 문제가 기초 트레이닝 문제보다 오히려 더 쉬운 것 같습니다.  
정답률 높은 순으로 풀면 자신감이 붙어서 좋습니다.  
한 문제에서 오래 막히는 경우, 질문으로 코드 남겨서 반례 요청 후 다른 문제 풀고 다시 와서 풀면 효율적입니다.

### 난이도 Lv. 0 100문제 풀이
<mark>옹알이 (1)</mark>
```
```

<mark>다음에 올 숫자</mark>
```
```

<mark>연속된 수의 합</mark>
```
```

<mark>종이 자르기</mark>
```
class Solution {
  public int solution(int M, int N) {
    int m_cut = M - 1;
    int n_cut = (N - 1) * M;
    
    return m_cut + n_cut;
  }
}
```
```
class Solution {
  public int solution(int M, int N) {
    return M * N - 1;
  }
}
```

<mark>문자열 밀기</mark>
```
```

<mark>잘라서 배열로 저장하기</mark>
```
class Solution {
  public String[] solution(String my_str, int n) {
    String[] answer = new String[(my_str.length() +n -1) / n];
    
    String str = "";
    
    for (int i = 0; i < my_str.length(); i++) {
      str += my_str.charAt(i);
      
      if (i % n == n-1 || i == my_str.length()-1) {
        answer[i / n] = str;
        str = "";
      }
    }
    
    return answer;
  }
}
```

<mark>7의 개수</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] array) {
    StringBuilder sb = new StringBuilder();
    
    for (int v : array) {
      sb.append(String.valueOf(v));
    }
    
    String allStr = sb.toString();
    
    return allStr.length() - allStr.replace("7", "").length();
  }
}
```
모든 숫자를 String으로 더하고, 7 제거한 숫자의 개수를 빼는 방식입니다.
```
class Solution {
  public int solution(int[] array) {
    int answer = 0;
    for(int a : array){
      while(a ? 0){
        if(a % 10 == 7){
          answer++;
        }
        a /= 10;
      }
    }
    return answer;
  }
}
```
1자리씩 검사하여 7의 개수를 더하는 방식입니다.

<mark>문자열 정렬하기 (2)</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string) {
    String answer = "";
    
    char[] c_arr = new char[my_string.length()];
    
    for (int i = 0; i < my_string.length(); i++) {
      char c = my_string.charAt(i);
      
      if (Character.isUpperCase(c)) {
        c = Character.toLowerCase(c);
      }
      
      c_arr[i] = c;
    }
    
    Arrays.sort(c_arr);
    
    return String.valueOf(c_arr);
  }
}
```
```
import java.util.*;

class Solution {
  public String solution(String my_string) {
    char[] c_arr = my_string.toLowerCase().toCharArray();
    
    Arrays.sort(c_arr);
    
    return String.valueOf(c_arr);
  }
}
```

<mark>세균 증식</mark>
```
class Solution {
  public int solution(int n, int t) {
    int answer = n;
    
    for (int i = 0; i < t; i++) {
      answer *= 2;
    }
    
    return answer;
  }
}
```

<mark>제곱수 판별하기</mark>
```
class Solution {
  public int solution(int n) {
    return (int) Math.sqrt(n) * 10 / 10 == Math.sqrt(n) ? 1 : 2;
  }
}
```
```
class Solution {
  public int solution(int n) {
    return Math.sqrt(n) % 1 == 0 ? 1 : 2;
  }
}
```

<mark>문자열안에 문자열</mark>
```
class Solution {
  public int solution(String str1, String str2) {
    return str1.replace(str2, "").equals(str1)? 2 : 1;
  }
}
```
아래처럼 contains 함수로 문자열 안에 문자열이 존재하는지 확인할 수도 있습니다.
```
class Solution {
  public int solution(String str1, String str2) {
    return str1.contains(str2) ? 1 : 2;
  }
}
```

<mark>OX퀴즈</mark>
```
```

<mark>자릿수 더하기</mark>
```
class Solution {
  public int solution(int n) {
    String str_n = String.valueOf(n);
    
    int answer = 0;
    
    for (char c : str_n.toCharArray()) {
      answer += c - '0';
    }
    
    return answer;
  }
}
```

<mark>n의 배수 고르기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int n, int[] numlist) {
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int v : numlist) {
      if (v % n == 0) {
        list.add(v);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>숫자 찾기</mark>
```
class Solution {
  public int solution(int num, int k) {
    int answer = -1;
    String num_str = String.valueOf(num);
    
    for (int i = 0; i < num_str.length(); i++) {
      if (num_str.charAt(i) - '0' == k) {
        answer = i + 1;
        break;
      }
    }
    
    return answer;
  }
}
```
```
class Solution {
  public int solution(int num, int k) {
    int answer = String.valueOf(num).indexOf(String.valueOf(k));
    
    return answer == -1 ? -1 : answer+1;
  }
}
```

<mark>배열의 유사도</mark>
```
import java.util.*;

class Solution {
  public int solution(String[] s1, String[] s2) {
    HashMap<String, String> hashMap = new HashMap<>();
    
    for (String s : s1) {
      hashMap.put(s, "");
    }
    
    for (String s : s2) {
      hashMap.put(s, "");
    }
    
    return s1.length + s2.length - hashMap.size();
  }
}
```
키만 필요하고, 값은 필요하지 않아서 아래처럼 HashSet을 사용하면 좋습니다.
```
import java.util.*;

class Solution {
  public int solution(String[] s1, String[] s2) {
    Set<String> set = new HashSet<>(Arrays.asList(s1));
    int answer = 0;
    
    for (String s : s2) {
      if (set.contains(s)) {
        answer++;
      }
    }
    
    return answer;
  }
}
```

<mark>문자열 계산하기</mark>
```
class Solution {
  public int solution(String my_string) {
    String[] strArr = my_string.split(" ");
    
    int answer = Integer.parseInt(strArr[0]);
    
    for (int i = 2; i < strArr.length; i += 2) {
      String sep = strArr[i-1];
      int num = Integer.parseInt(strArr[i]);
      
      if (sep.equals("+")) {
        answer += num;
      } else {
        answer -= num;
      }
    }
    
    return answer;
  }
}
```

<mark>가장 큰 수 찾기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] array) {
    int[] answer = {};
    
    int[] sort_array = Arrays.copyOf(array, array.length);
    
    Arrays.sort(sort_array);
    
    int max = sort_array[sort_array.length - 1];
    
    for (int i = 0; i < array.length; i++) {
      if (array[i] == max) {
        answer = new int[]{ max, i };
      }
    }
    
    return answer;
  }
}
```

<mark>편지</mark>
```
class Solution {
  public int solution(String message) {
    return message.length() * 2;
  }
}
```

<mark>약수 구하기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int n) {
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int i = 1; i <= n; i++) {
      if (n % i == 0) {
        list.add(i);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```

<mark>한 번만 등장한 문자</mark>
```
import java.util.*;

class Solution {
  public String solution(String s) {
    String answer = "";
    
    String[] sArr = s.split("");
    
    Arrays.sort(sArr);
    
    boolean same = false;
    String nextStr = "";
    
    for (int i = 0; i < sArr.length-1; i++) {
      String curStr = sArr[i];
      nextStr = sArr[i+1];
      
      if (curStr.equals(nextStr)) {
        same = true;
          
      } else if (same == false) {
        answer += curStr;
          
      } else {
        same = false;
      }
    }
    
    if (same == false) {
      answer += sArr[sArr.length-1];
    }
    
    return answer;
  }
}
```
```
class Solution {
  public String solution(String s) {
    int[] alpha = new int[26];
    for(char c : s.toCharArray()){
      alpha[c - 'a']++;
    }

    StringBuilder answer = new StringBuilder();
    for(int i = 0; i < 26; i++){
      if(alpha[i] == 1){
        answer.append((char)(i + 'a'));
      }
    }
    return answer.toString();
  }
}
```

<mark>인덱스 바꾸기</mark>
```
class Solution {
  public String solution(String my_string, int num1, int num2) {
    String answer = "";
    
    char str1 = my_string.charAt(num1);
    char str2 = my_string.charAt(num2);
    
    return my_string.substring(0, num1) + str2 + my_string.substring(num1+1, num2) + str1 +  my_string.substring(num2+1, my_string.length());
  }
}
```
```
class Solution {
  public String solution(String my_string, int num1, int num2) {
    char[] charArr = my_string.toCharArray();
    
    charArr[num1] = my_string.charAt(num2);
    charArr[num2] = my_string.charAt(num1);
        
    return String.valueOf(charArr);
      
  }
}
```

<mark>영어가 싫어요</mark>
```
import java.util.*;

class Solution {
  public long solution(String numbers) {
    HashMap<String, String> hashMap = new HashMap<>();
    
    hashMap.put("zero", "0");
    hashMap.put("one", "1");
    hashMap.put("two", "2");
    hashMap.put("three", "3");
    hashMap.put("four", "4");
    hashMap.put("five", "5");
    hashMap.put("six", "6");
    hashMap.put("seven", "7");
    hashMap.put("eight", "8");
    hashMap.put("nine", "9");
    
    String subStr = "";
    String result = "";
    
    for (int i = 0; i < numbers.length(); i++) {
      subStr += numbers.charAt(i);
      
      if (hashMap.containsKey(subStr)) {
        result += hashMap.get(subStr);
        subStr = "";
      }
    }
    
    return Long.parseLong(result);
  }
}
```
아래처럼, replace를 사용하면 더 간결하게 구현할 수 있습니다.
```
import java.util.*;

class Solution {
  public long solution(String numbers) {
    String[] numArr = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
    
    for (int i = 0; i < numArr.length; i++) {
      numbers = numbers.replace(numArr[i], String.valueOf(i));
    }
    
    return Long.parseLong(numbers);
  }
}
```

<mark>대문자와 소문자</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string) {
    StringBuilder sb = new StringBuilder();
    
    for (char c : my_string.toCharArray()) {
      if (Character.isUpperCase(c)) {
        sb.append(Character.toLowerCase(c));
      } else {
        sb.append(Character.toUpperCase(c));
      }
    }
    
    return sb.toString();
  }
}
```

<mark>암호 해독</mark>
```
import java.util.*;

class Solution {
  public String solution(String cipher, int code) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = code-1; i < cipher.length(); i += code) {
      sb.append(cipher.charAt(i));
    }
    
    return sb.toString();
  }
}
```

<mark>369게임</mark>
```
class Solution {
  public int solution(int order) {
    String str = String.valueOf(order);
    
    String remove_str = str.replaceAll("[369]", "");
    
    return str.length() - remove_str.length();
  }
}
```

<mark>가까운 수</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] array, int n) {
    int answer = 0;
    
    Arrays.sort(array);
    
    int min_diff = array[array.length-1] + n;
    
    for (int i = 0; i < array.length; i++) {
      int cur_diff = Math.abs(array[i] - n);
      
      if (min_diff > cur_diff) {
        min_diff = cur_diff;
        answer = array[i];
      }
    }
    
    return answer;
  }
}
```

<mark>삼각형의 완성조건 (1)</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] sides) {
    int answer = 2;
    
    Arrays.sort(sides);
    
    if (sides[2] < sides[0] + sides[1]) {
      answer = 1;
    }
    
    return answer;
  }
}
```

<mark>중복된 문자 제거</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string) {
    Set<Character> set = new LinkedHashSet<>();
    
    for (char c : my_string.toCharArray()) {
      set.add(c);
    }
    
    String answer = "";
    for (char c : set) {
      answer += c;
    }
    
    return answer;
  }
}
```
LinkedHashSet을 사용하면 순서를 유지하며 중복이 제거됩니다.
```
import java.util.*;

class Solution {
  public String solution(String my_string) {
    String[] strArr = my_string.split("");
    
    Set<String> set = new LinkedHashSet<>(Arrays.asList(strArr));
    
    return String.join("", set);
  }
}
```
위와 같이, 더 간략하게 구현이 가능합니다.

<mark>k의 개수</mark>
```
class Solution {
  public int solution(int i, int j, int k) {
    int answer = 0;
    String str_k = String.valueOf(k);
    
    for (int num = i; num <= j; num++) {
      String str = String.valueOf(num);
      
      for (char c : str.toCharArray()) {
        if (str.indexOf(str_k) != -1) {
          str = str.replaceFirst(str_k, "");
          answer++;
        }
      }
    }
    
    return answer;
  }
}
```
```
import java.util.*;

class Solution {
  public int solution(int i, int j, int k) {
    StringBuilder sb = new StringBuilder();
    
    for (int num = i; num <= j; num++) {
      sb.append(num);
    }
    
    String allStr = sb.toString();
    
    return allStr.length() - allStr.replace(String.valueOf(k), "").length();
  }
}
```

<mark>A로 B 만들기</mark>
```
import java.util.*;

class Solution {
  public int solution(String before, String after) {
    String[] beforeArr = before.split("");
    StringBuilder after_sb = new StringBuilder(after);
    
    for (String str : beforeArr) {
      int i = after_sb.toString().indexOf(str);
      
      if (i != -1) {
        after_sb.deleteCharAt(i);
      }
    }
    
    return after_sb.toString().isEmpty() ? 1 : 0;
  }
}
```
```
class Solution {
  public int solution(String before, String after) {
    String[] beforeArr = before.split("");
    
    for (String str : beforeArr) {
      int i = after.indexOf(str);
      
      if (i != -1) {
        after = after.replaceFirst(str, "");
      }
    }
    
    return after.isEmpty() ? 1 : 0;
  }
}
```
```
import java.util.*;

class Solution {
  public int solution(String before, String after) {
    char[] beforeSort = before.toCharArray();
    char[] afterSort = after.toCharArray();
    
    Arrays.sort(beforeSort);
    Arrays.sort(afterSort);
    
    return String.valueOf(beforeSort).equals(String.valueOf(afterSort)) ? 1 : 0;
  }
}
```

<mark>이진수 더하기</mark>
```
class Solution {
  public String solution(String bin1, String bin2) {
    int sum = Integer.parseInt(bin1, 2) + Integer.parseInt(bin2, 2);
    
    return Integer.toString(sum, 2);
  }
}
```

<mark>치킨 쿠폰</mark>
```
class Solution {
  public int solution(int chicken) {
    int service = 0;
    
    while (chicken >= 10) {
      int new_service = chicken / 10;
      service += new_service;
      chicken = chicken % 10 + new_service;
    }
    
    return service;
  }
}
```

<mark>로그인 성공?</mark>
```
import java.util.*;

class Solution {
  public String solution(String[] id_pw, String[][] db) {
    String answer = "fail";
    HashMap<String, String> hashMap = new HashMap<>();
    
    for (int i = 0; i < db.length; i++) {
      hashMap.put(db[i][0], db[i][1]);
    }
    
    if (hashMap.containsKey(id_pw[0])) {
      if (id_pw[1].equals(hashMap.get(id_pw[0]))) {
        answer = "login";
      } else {
        answer = "wrong pw";
      }
    }
    
    return answer;
  }
}
```
아래처럼 HashMap을 사용하지 않고 간략하게 풀 수 있습니다.
```
class Solution {
  public String solution(String[] id_pw, String[][] db) {
    String answer = "fail";
    
    for (String[] user : db) {
      if (id_pw[0].equals(user[0])) {
        if (id_pw[1].equals(user[1])) {
          answer = "login";
        } else {
          answer = "wrong pw";
        }
      }
    }
    
    return answer;
  }
}
```

<mark>등수 매기기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[][] score) {
    int n = score.length;
    int[] totalScore = new int[n];
    int[] ranks = new int[n];

    // 학생들의 총점 계산
    for (int i = 0; i < n; i++) {
      totalScore[i] = score[i][0] + score[i][1];
    }

    // 각 학생의 등수 계산
    for (int i = 0; i < n; i++) {
      int rank = 1;
      for (int j = 0; j < n; j++) {
        if (totalScore[j] > totalScore[i]) {
          rank++;
        }
      }
      ranks[i] = rank;
    }

    return ranks;
  }
}
```
아래처럼, ArrayList의 indexOf 함수를 이용하여 등수를 매기면 좋습니다.
```
import java.util.*;

class Solution {
  public int[] solution(int[][] score) {
      ArrayList<Integer> list = new ArrayList<>();
      
      for (int[] v : score) {
        list.add(v[0] + v[1]);
      }
      
      int[] answer = new int[score.length];
          
      Collections.sort(list, Collections.reverseOrder());
      
      for (int i = 0; i < score.length; i++) {
        answer[i] = list.indexOf(score[i][0] + score[i][1]) + 1;
      }
          
      return answer;
  }
}
```
/2로 평균을 구하지 않고, 합계로 등수를 매기면 정확도가 높아집니다.

<mark>특이한 정렬</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] numlist, int n) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(
      (a, b) -> {
        int diffA = Math.abs(a - n);
        int diffB = Math.abs(b - n);
        
        if (diffA != diffB) {
          // 절대값 차이가 다르면 절대값 치이 오름차순
          return diffA - diffB;
        } else {
          // 절대값 차이가 같으면 숫자 내림차순
          return b - a;
        }
      }
    );
    
    for (int num : numlist) {
      pq.add(num);
    }
    
    int[] answer = new int[pq.size()];
    
    int i = 0;
    while(!pq.isEmpty()) {
      answer[i++] = pq.poll();
    }
      
    return answer;
  }
}
```
우선순위 큐 객체를 생성하며 정렬 조건을 설정하면, 쉽게 정렬할 수 있습니다.

<mark>유한소수 판별하기</mark>
```
class Solution {
  public int solution(int a, int b) {
    int answer = 1;
    
    for (int i = 2; i <= b; i++) {
      if (a % i == 0 && b % i == 0) {
        a /= i;
        b /= i;
      }
    }

    while (b > 1) {
      if (b % 2 == 0) {
        b /= 2;
        continue;
      }
      
      if (b % 5 == 0) {
        b /= 5;
        continue;
      }
      
      return 2;
    }
    
    return answer;
  }
}
```
```
class Solution {
  public int solution(int a, int b) {
    int answer = 1;
    
    for (int i = 2; i <= b; i++) {
      if (a % i == 0 && b % i == 0) {
        a /= i;
        b /= i;
      }
    }

    while (b % 2 == 0) {
      b /= 2;
    }
    
    while (b % 5 == 0) {
      b /= 5;
    }
    
    if (b != 1) {
      answer = 2;
    }
    
    return answer;
  }
}
```
분모에서 2의 배수, 5의 배수를 모두 제거한 뒤 남은 수가 1이 아니면 무한소수입니다.

<mark>평행</mark>
```
```

<mark>저주의 숫자 3</mark>
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    int cnt = 0;
    
    int i = 0;
    while (cnt != n) {
      i++;
      
      if (i % 3 == 0) {
        continue;
      }
      
      String i_str = String.valueOf(i);
      
      boolean isThree = false;
      
      for (char c : i_str.toCharArray()) {
        if (c == '3') {
          isThree = true;
          break;
        }
      }
      
      if (isThree == true) {
        continue;
      }
      
      cnt++;
      
      if (cnt == n) {
        answer = i;
      }
    }
    
    return answer;
  }
}
```
아래처럼 contains를 사용하면 간결하게 문자열 포함 여부를 알 수 있습니다.
```
class Solution {
  public int solution(int n) {
    for (int i = 1; i <= n; i++) {
      String str = String.valueOf(i);
      
      if (i % 3 == 0 || str.contains("3")) {
        n++;
      }
    }
    
    return n;
  }
}
```

<mark>외계어 사전</mark>
```
import java.util.*;

class Solution {
  public int solution(String[] spell, String[] dic) {
    Arrays.sort(spell);
    
    String spellStr = String.join("", spell);
    
    for (int i = 0; i < dic.length; i++) {
      String[] dicArr = dic[i].split("");
      
      Arrays.sort(dicArr);
      
      String dicStr = String.join("", dicArr);
      
      if (spellStr.equals(dicStr)) {
        return 1;
      }
    }
    
    return 2;
  }
}
```

<mark>삼각형의 완성조건 (2)</mark>
```
class Solution {
  public int solution(int[] sides) {;
    int side_3_min = Math.abs(sides[0] - sides[1]) +1;
    int side_3_max = sides[0] + sides[1] -1;
    
    return side_3_max - side_3_min +1; // side_3_min이 제거되기 때문에, 경우의 수 +1 추가
  }
}
```
삼각형 두 변 a, b가 있을 때 마지막 변 c를 구하는 공식은 | a - b | +1 <= c <= a + b -1 입니다.  
삼각형의 불등식에서 c는 두 변의 차보다 크고, 두 변의 합보다 작아야 하기 때문입니다.
```
class Solution {
  public int solution(int[] sides) {
    int min = Math.min(sides[0], sides[1]);
    
    return min + min - 1;
  }
}
```
위 코드는 3번째 변으로 가능한 경우의 수를 구하는 간략화된 공식입니다.

<mark>안전지대</mark>
```
```

<mark>숨어있는 숫자의 덧셈 (2)</mark>
```
class Solution {
  public int solution(String my_string) {
    int answer = 0;
    
    String str = "";
    
    for (char c : my_string.toCharArray()) {
      if (c - '0' >= 0 && c - '0' <= 9) {
        str += c;
          
      } else {
        if (!str.isEmpty()) {
          answer += Integer.parseInt(str);
          str = "";
        }
      }
    }
    
    if (!str.isEmpty()) {
      answer += Integer.parseInt(str);
    }
    
    return answer;
  }
}
```
아래처럼 정규표현식과 split을 이용하면 더욱 간결하게 구현할 수 있습니다.
```
class Solution {
  public int solution(String my_string) {
    int answer = 0;
    
    String[] strArr = my_string.replaceAll("[a-zA-Z]", " ").split(" ");
    
    for (String str : strArr) {
      if (!str.isEmpty()) {
        answer += Integer.parseInt(str);
      }
    }
    
    return answer;
  }
}
```

<mark>다항식 더하기</mark>
```
```

<mark>최댓값 만들기 (2)</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] numbers) {
    Arrays.sort(numbers);
    
    int plus_max = numbers[numbers.length -1] * numbers[numbers.length -2];
    int minus_max = numbers[0] * numbers[1];
    
    return Math.max(plus_max, minus_max);
  }
}
```

<mark>캐릭터의 좌표</mark>
```
import java.util.*;

class Solution {
  public int[] solution(String[] keyinput, int[] board) {
    int[] answer = {0, 0};
    
    HashMap<String, int[]> moveMap = new HashMap<>();
    
    moveMap.put("up", new int[]{0, 1});
    moveMap.put("down", new int[]{0, -1});
    moveMap.put("left", new int[]{-1, 0});
    moveMap.put("right", new int[]{1, 0});
    
    int x_range = (board[0] - 1) / 2;
    int y_range = (board[1] - 1) / 2;
    
    int min_x = -x_range;
    int max_x = x_range;
    int min_y = -y_range;
    int max_y = y_range;
    
    for (String v : keyinput) {
      if (v.equals("up") && answer[1] == max_y) {
        continue;
      }
      
      if (v.equals("down") && answer[1] == min_y) {
        continue;
      }
      
      if (v.equals("left") && answer[0] == min_x) {
        continue;
      }
      
      if (v.equals("right") && answer[0] == max_x) {
        continue;
      }
      
      int[] move = moveMap.get(v);
      
      answer[0] += move[0];
      answer[1] += move[1];
    }
    
    return answer;
  }
}
```

<mark>직사각형 넓이 구하기</mark>
```
class Solution {
  public int solution(int[][] dots) {
    int answer = 0;
    
    int x1 = -1;
    int x2 = -1;
    int y1 = -1;
    int y2 = -1;
    
    for (int[] v : dots) {
        if (x1 == -1) {
          x1 = v[0];
        } else if (x2 == -1 && x1 != v[0]) {
          x2 = v[0];
        }
        
        if (y1 == -1) {
          y1 = v[1];
        } else if (y2 == -1 && y1 != v[1]) {
          y2 = v[1];
        }
    }
    
    if (x2 < x1) {
      int temp = x1;
      x1 = x2;
      x2 = temp;
    }
    
    if (y2 < y1) {
      int temp = y1;
      y1 = y2;
      y2 = temp;
    }
    
    return (x2 - x1) * (y2 - y1);
  }
}
```

<mark>배열 원소의 길이</mark>
```
class Solution {
  public int[] solution(String[] strlist) {
    int[] answer = new int[strlist.length];
    
    for (int i = 0; i < strlist.length; i++) {
      answer[i] = strlist[i].length();
    }
    
    return answer;
  }
}
```

<mark>컨트롤 제트</mark>
```
class Solution {
  public int solution(String s) {
    int answer = 0;
    
    String[] sArr = s.split(" ");
    int prev_num = 0;
    
    for (int i = 0; i < sArr.length; i++) {
      String cur_str = sArr[i];
      
      if ("Z".equals(cur_str)) {
        answer -= prev_num;
          
      } else {
        int cur_num = Integer.parseInt(cur_str);
        answer += cur_num;
        prev_num = cur_num;
      }
    }
    
    return answer;
  }
}
```
아래처럼, 스택을 이용하기 좋은 문제입니다.
```
import java.util.*;

class Solution {
  public int solution(String s) {
    int answer = 0;
    
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (String str : s.split(" ")) {
      if (str.equals("Z")) {
        stack.pop();
      } else {
        stack.push(Integer.parseInt(str));
      }
    }
            
    for (int v : stack) {
      System.out.println(v);
      answer += v;
    }
    
    return answer;
  }
}
```

<mark>소인수분해</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int n) {
    ArrayList<Integer> list = new ArrayList<>();
    
    while (n > 1) {
      for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
          n /= i;
          if (!list.contains(i)) {
            list.add(i);
          }
          break;
        }
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    return answer;
  }
}
```
while (n > 1) 하는 이유는, 1은 더이상 나눌 수 없기 떄문입니다.
```
import java.util.*;

class Solution {
  public int[] solution(int n) {
    Set<Integer> set = new LinkedHashSet<>();
    
    while (n > 1) {
      for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
          n /= i;
          set.add(i);
          break;
        }
      }
    }
    
    int[] answer = new int[set.size()];
    int i = 0;
    
    for (int v : set) {
      answer[i] = v;
      i++;
    }
    
    return answer;
  }
}
```
ArrayList 대신 LinkedHashSet을 사용하면 더 쉽게 중복을 제거할 수 있습니다.

<mark>숨어있는 숫자의 덧셈 (1)</mark>
```
class Solution {
  public int solution(String my_string) {
    int answer = 0;
    
    for (int i = 0; i < my_string.length(); i++) {
      char c = my_string.charAt(i);
      
      if (c > '0' && c <= '9') {
        answer += c - '0';
      }
    }
    
    return answer;
  }
}
```
아래처럼 toCharArray()를 사용하면 쉽게 문자를 추출할 수 있습니다.
```
class Solution {
  public int solution(String my_string) {
    int answer = 0;
    
    for (char c : my_string.toCharArray()) {
      if (c > '0' && c <= '9') {
        answer += c - '0';
      }
    }
    
    return answer;
  }
}
```

<mark>문자열 정렬하기 (1)</mark>
```
import java.util.*;

class Solution {
  public int[] solution(String my_string) {
    ArrayList<Integer> list = new ArrayList<>();
    
    for (char c : my_string.toCharArray()) {
      int i = c - '0';
      
      if (i >= 0 && i <= 9) {
        list.add(i);
      }
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
    
    Arrays.sort(answer);
    
    return answer;
  }
}
```
아래처럼 replaceAll으로 String의 모든 영어 소문자를 제거할 수 있습니다.
```
import java.util.*;

class Solution {
  public int[] solution(String my_string) {
    my_string = my_string.replaceAll("[a-z]", "");
    
    int[] answer = new int[my_string.length()];
    
    for (int i = 0; i < answer.length; i++) {
      answer[i] = my_string.charAt(i) - '0';
    }
    
    Arrays.sort(answer);
    
    return answer;
  }
}
```

<mark>모음 제거</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string) {
    StringBuilder sb = new StringBuilder();
    Set<Character> set = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));
    
    for (char c : my_string.toCharArray()) {
        if(!set.contains(c)) {
            sb.append(c);
        }
    }
    
    return sb.toString();
  }
}
```
```
mport java.util.*;

class Solution {
  public String solution(String my_string) {
    return my_string.replaceAll("[aeiou]", "");
  }
}
```

<mark>팩토리얼</mark>
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    int sum = 0;
    int cnt = 0;
    
    while (true) {
      if (sum == n) {
        break;
      } else if (sum > n) {
        cnt--;
        break;
      }
      
      cnt++;
      sum = factorial(cnt);
    }
    
    return cnt;
  }
  
  public int factorial(int i) {
    if (i == 0) {
      return 1;
    }
    
    return i * factorial(i-1);
  }
}
```
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    
    for (int i = 1; factorial(i) <= n; i++) {
      answer = i;
    }
    
    return answer;
  }
  
  public int factorial(int i) {
    if (i == 1) {
      return 1;
    }
    
    return i * factorial(i-1);
  }
}
```

<mark>최댓값 만들기(1)</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] numbers) {
    Arrays.sort(numbers);

    return numbers[numbers.length-1] * numbers[numbers.length-2];
  }
}
```

<mark>합성수 찾기</mark>
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    
    for (int i = 1; i <= n; i++) {
      int cnt = 0;
      
      for (int j = 1; j <= i; j++) {
        if (i % j == 0) {
          cnt++;
        }
        
        if (cnt == 3) {
          answer++;
          break;
        }
      }
    }
    
    return answer;
  }
}
```

<mark>주사위의 개수</mark>
```
class Solution {
  public int solution(int[] box, int n) {
    return (box[0] / n) * (box[1] / n) * (box[2] / n);
  }
}
```

<mark>배열 회전시키기</mark>
```
class Solution {
  public int[] solution(int[] numbers, String direction) {
    int[] answer = new int[numbers.length];
    
    if (direction.equals("right")) {
      answer[0] = numbers[numbers.length-1];
      
      for (int i = 0; i < numbers.length-1; i++) {
        answer[i+1] = numbers[i];
      }
        
    } else {
      for (int i = 1; i < numbers.length; i++) {
        answer[i-1] = numbers[i];
      }
      
      answer[numbers.length-1] = numbers[0];
    }
    
    return answer;
  }
}
```

<mark>공 던지기</mark>
```
class Solution {
  public int solution(int[] numbers, int k) {
    return numbers[(k-1) * 2 % numbers.length];
  }
}
```

<mark>2차원으로 만들기</mark>
```
import java.util.*;

class Solution {
  public int[][] solution(int[] num_list, int n) {
    ArrayList<Integer[]> list = new ArrayList<>();
    
    Integer[] i_arr = new Integer[n];
    
    for (int i = 0; i < num_list.length; i++) {
      if (i % n == 0) {
        i_arr = new Integer[n];
      }
      
      i_arr[i % n] = num_list[i];
      
      if (i % n == 0) {
        list.add(i_arr);
      }
    }
    
    int[][] answer = new int[list.size()][];
    
    for (int i = 0; i < list.size(); i++) {
      int[] intArr = new int[n];
      
      Integer[] integerArr = list.get(i);
      
      for (int j = 0; j < integerArr.length; j++) {
        intArr[j] = integerArr[j].intValue();
      }
      
      answer[i] = intArr;
    }
    
    return answer;
  }
}
```
배열의 개수가 정해진 경우, 위와 같이 ArrayList를 사용하면 코드가 복잡해질 수 있습니다.
```
import java.util.*;

class Solution {
  public int[][] solution(int[] num_list, int n) {
      
    int[][] answer = new int[num_list.length / n][n];
    
    for (int i = 0; i < num_list.length; i++) {
      answer[i / n][i % n] = num_list[i];
    }
    
    return answer;
  }
}
```

<mark>점의 위치 구하기</mark>
```
class Solution {
  public int solution(int[] dot) {
    int answer = 0;
    
    int x = dot[0];
    int y = dot[1];
    
    if (x > 0 && y > 0) {
      answer = 1;
    } else if (x > 0) {
      answer = 4;
    } else if (y > 0) {
      answer = 2;
    } else {
      answer = 3;
    }
    
    return answer;
  }
}
```

<mark>구슬을 나누는 경우의 수</mark>
```
class Solution {
  public int solution(int balls, int share) {
    return combination(balls, share);
  }
  
  public int combination(int n, int m) {
    if (m == 0 || n == m) {
      return 1;
    }
    
    return combination(n - 1, m) + combination(n -1, m -1);
  }
}
```
순서가 없는 서로 다른 n개에서 m개를 선택하는 조합 코드입니다.
```
combination(4, 2) == 6

(3, 2)=3
(2, 2)=1, (2, 1)=2 
          (1, 1)=1, (1, 0)=1

(3, 1)=3
(2, 1)=2, (2, 0)=1
```
위 combination 재귀 함수를 디버깅하면 이런 형태입니다.  
return 로직을 한번에 계산하지 말고, 앞부분 (3, 2) 계산 후 뒷부분(3, 1)을 계산하면 이해가 쉽습니다.  
(2, 1)처럼 중복 호출이 발생하니, 메모이제이션으로 계산한 값을 저장해두고 재사용하면 효율적입니다.

<mark>가위 바위 보</mark>
```
class Solution {
  public String solution(String rsp) {
    String answer = "";
    
    for (int i = 0; i < rsp.length(); i++) {
      char c = rsp.charAt(i);
      
      switch(c) {
        case '2':
          c = '0';
          break;
        case '0':
          c = '5';
          break;
        case '5':
          c = '2';
          break;
      }
              
      answer += c;
    }
    
    return answer;
  }
}
```
문자열은 아래처럼 StringBuilder로 더하는 것이 좋습니다.
```
import java.util.*;

class Solution {
  public String solution(String rsp) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = 0; i < rsp.length(); i++) {
      char c = rsp.charAt(i);
      
      switch(c) {
        case '2':
          c = '0';
          break;
        case '0':
          c = '5';
          break;
        case '5':
          c = '2';
          break;
      }
              
      sb.append(c);
    }
    
    return sb.toString();
  }
}
```

<mark>모스부호 (1)</mark>
```
import java.util.*;

class Solution {
  public String solution(String letter) {
    String answer = "";
    
    HashMap<String, String> map = new HashMap<>();
    
    map.put(".-", "a");
    map.put("-...", "b");
    map.put("-.-.", "c");
    map.put("-..", "d");
    map.put(".", "e");
    map.put("..-.", "f");
    map.put("--.", "g");
    map.put("....", "h");
    map.put("..", "i");
    map.put(".---", "j");
    map.put("-.-", "k");
    map.put(".-..", "l");
    map.put("--", "m");
    map.put("-.", "n");
    map.put("---", "o");
    map.put(".--.", "p");
    map.put("--.-", "q");
    map.put(".-.", "r");
    map.put("...", "s");
    map.put("-", "t");
    map.put("..-", "u");
    map.put("...-", "v");
    map.put(".--", "w");
    map.put("-..-", "x");
    map.put("-.--", "y");
    map.put("--..", "z");
    
    String[] strArr = letter.split(" ");
    
    for (String str : strArr) {
      answer += map.get(str);
    }
    
    return answer;
  }
}
```

<mark>개미 군단</mark>
```
class Solution {
  public int solution(int hp) {
    int answer = 0;
    
    answer += hp / 5;
    hp %= 5;

    answer += hp / 3;
    hp %= 3;
    
    return answer += hp;
  }
}
```

<mark>순서쌍의 개수</mark>
```
class Solution {
  public int solution(int n) {
    int cnt = 0;
    
    for (int i = 1; i <= n; i++) {
      if (n % i == 0) {
        cnt++;
      }
    }
    
    return cnt;
  }
}
```

<mark>진료순서 정하기</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int[] emergency) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        
    for (int v : emergency) {
      pq.add(v);
    }
    
    int[] answer = new int[emergency.length];
    
    int lank = 1;
    
    while (!pq.isEmpty()) {
      int num = pq.poll();
      int num_i = 0;
      
      for (int i = 0; i < emergency.length; i++) {
        if (emergency[i] == num) {
          num_i = i;
          break;
        }
      }
      
      answer[num_i] = lank;
      
      lank++;
    }
    
    return answer;
  }
}
```

<mark>외계행성의 나이</mark>
```
class Solution {
  public String solution(int age) {
    String[] universe_age = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j"};
    
    String answer = "";
    
    for (char c : String.valueOf(age).toCharArray()) {
      answer += universe_age[c - '0'];
    }
    
    return answer;
  }
}
```

<mark>배열 자르기</mark>
```
class Solution {
  public int[] solution(int[] numbers, int num1, int num2) {
    int[] answer = new int[num2 - num1 +1];
    
    for (int i = num1; i <= num2; i++) {
      answer[i - num1] = numbers[i];
    }
    
    return answer;
  }
}
```
```
import java.util.*;

class Solution {
  public int[] solution(int[] numbers, int num1, int num2) {
    return Arrays.copyOfRange(numbers, num1, num2+1);
  }
}
```

<mark>짝수의 합</mark>
```
class Solution {
  public int solution(int n) {
    int answer = 0;
    
    for (int i = 2; i <= n; i += 2) {
      answer += i;
    }
    
    return answer;
  }
}
```

<mark>양꼬치</mark>
```
class Solution {
  public int solution(int n, int k) {
    
    int service_k = n / 10;  
    
    return (n * 12000) + ((k - service_k) * 2000);
  }
}
```

<mark>각도기</mark>
```
class Solution {
  public int solution(int angle) {
    int answer = 0;
    
    if (angle < 90) {
      answer = 1;
    } else if (angle == 90) {
      answer = 2;
    } else if (angle < 180) {
      answer = 3;
    } else {
      answer = 4;
    }
    
    return answer;
  }
}
```

<mark>특정 문자 제거하기</mark>
```
class Solution {
  public String solution(String my_string, String letter) {
    int letter_i = my_string.indexOf(letter);
    
    while (letter_i != -1) {
      my_string = my_string.substring(0, letter_i) + my_string.substring(letter_i +1, my_string.length());
      
      letter_i = my_string.indexOf(letter);
    }
        
    return my_string;
  }
}
```
아래처럼 replace 함수를 이용하면 더 간결하게 할 수 있습니다.
```
class Solution {
    public String solution(String my_string, String letter) {
        return my_string.replace(letter, "");
    }
}
```

<mark>문자 반복 출력하기</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string, int n) {
    StringBuilder sb = new StringBuilder();
    
    for (char c : my_string.toCharArray()) {
      for (int i = 0; i < n; i++) {
        sb.append(c);
      }
    }
    
    return sb.toString();
  }
}
```

<mark>짝수 홀수 개수</mark>
```
class Solution {
  public int[] solution(int[] num_list) {
    int[] answer = new int[2];
    
    for (int num : num_list) {
      if (num % 2 == 0) {
        answer[0]++;
      } else {
        answer[1]++;
      }
    }
    
    return answer;
  }
}
```

<mark>직각삼각형 출력하기</mark>
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    
    for (int i = 0; i < n; i++) {
      for (int j = 0; j <= i; j++) {
        System.out.print("*");
      }
      
      System.out.println();
    }
  }
}
```
아래처럼 repeat 함수를 사용하면 더 간결하게 문자열을 반복할 수 있습니다.
```
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    
    for (int i = 1; i <= n; i++) {
      System.out.println("*".repeat(i));
    }
  }
}
```

<mark>문자열 뒤집기</mark>
```
import java.util.*;

class Solution {
  public String solution(String my_string) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = my_string.length()-1; i >= 0; i--) {
      sb.append(my_string.charAt(i));
    }
    
    return sb.toString();
  }
}
```

<mark>배열 뒤집기</mark>
```
class Solution {
  public int[] solution(int[] num_list) {
    int[] answer = new int[num_list.length];
    
    for (int i = num_list.length-1; i >= 0; i--) {
      answer[num_list.length-1 - i] = num_list[i];
    }
    
    return answer;
  }
}
```
```
class Solution {
  public int[] solution(int[] num_list) {
    int[] answer = new int[num_list.length];
    
    for (int i = 0; i < num_list.length; i++) {
      answer[i] = num_list[num_list.length-1 -i];
    }
    
    return answer;
  }
}
```

<mark>나이 출력</mark>
```
class Solution {
  public int solution(int age) {
    return 2022 - age + 1;
  }
}
```

<mark>아이스 아메리카노</mark>
```
class Solution {
  public int[] solution(int money) {
    int[] answer = new int[2];
    
    answer[0] = money / 5500;
    answer[1] = money % 5500;
    
    return answer;
  }
}
```
```
class Solution {
  public int[] solution(int money) {
    int[] answer = { money / 5500, money % 5500 };
    
    return answer;
  }
}
```

<mark>옷가게 할인 받기</mark>
```
class Solution {
  public int solution(int price) {
    int answer = 0;
    
    if (price >= 500000) {
      answer = (int) (price * 0.8);
    } else if (price >= 300000) {
      answer = (int) (price * 0.9);
    } else if (price >= 100000) {
      answer = (int) (price * 0.95);
    } else {
      answer = price;
    }
    
    return answer;
  }
}
```

<mark>배열의 평균값</mark>
```
class Solution {
  public double solution(int[] numbers) {
    int sum = 0;
    
    for (int num : numbers) {
      sum += num;
    }
    
    return (double) sum / numbers.length;
  }
}
```
int 둘 중 하나를 double로 형변환 하면, 나눈 결과값이 정수가 아니라 실수로 나옵니다.

<mark>피자 나눠 먹기 (3)</mark>
```
class Solution {
  public int solution(int slice, int n) {
    return (n + slice -1) / slice;
  }
}
```
```
class Solution {
  public int solution(int slice, int n) {
    return (int) Math.ceil((double) n / slice);
  }
}
```

<mark>피자 나눠 먹기 (2)</mark>
```
class Solution {
  public int solution(int n) {
    int cnt = 1;
    
    while (true) {
      if (cnt * 6 % n == 0) {
        break;
      }
      
      cnt++;
    }
    
    return cnt;
  }
}
```

<mark>피자 나눠 먹기 (1)</mark>
```
class Solution {
  public int solution(int n) {
    // 올림 한 실수 값을 정수로 반환
    return (int) Math.ceil((double) n / 7);
  }
}
```
```
class Solution {
  public int solution(int n) {
    return (n + 6) / 7;
  }
}
```

<mark>짝수는 싫어요</mark>
```
import java.util.*;

class Solution {
  public int[] solution(int n) {
    ArrayList<Integer> list = new ArrayList<>();
    
    for (int i = 1; i <= n; i += 2) {
      list.add(i);
    }
    
    int[] answer = new int[list.size()];
    
    for (int i = 0; i < list.size(); i++) {
      answer[i] = list.get(i);
    }
        
    return answer;
  }
}
```

<mark>최빈값 구하기</mark>
```
```

<mark>중앙값 구하기</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] array) {
    Arrays.sort(array);
    
    return array[array.length / 2];
  }
}
}
```

<mark>나머지 구하기</mark>
```
class Solution {
  public int solution(int num1, int num2) {
    return num1 % num2;
  }
}
```

<mark>배열 두 배 만들기</mark>
```
class Solution {
  public int[] solution(int[] numbers) {
    for (int i = 0; i < numbers.length; i++) {
      numbers[i] *= 2;
    }
    
    return numbers;
  }
}
```

<mark>분수의 덧셈</mark>
```
```

<mark>숫자 비교하기</mark>
```
class Solution {
  public int solution(int num1, int num2) {
    return num1 == num2? 1 : -1;
  }
}
```

<mark>두 수의 나눗셈</mark>
```
class Solution {
  public int solution(int num1, int num2) {
    return (int) ( (double) num1 / num2 * 1000);
  }
}
```

<mark>몫 구하기</mark>
```
class Solution {
  public int solution(int num1, int num2) {
    return num1 / num2;
  }
}
```

<mark>두 수의 곱</mark>
```
class Solution {
  public int solution(int num1, int num2) {
    return num1 * num2;
  }
}
```

<mark>두 수의 차</mark>
```
class Solution {
  public int solution(int num1, int num2) {
    return num1 - num2;
  }
}
```

<mark>두 수의 합</mark>
```
```

<mark>머쓱이보다 키 큰 사람</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] array, int height) {
    int answer = 0;
    
    for (int v : array) {
      if (v > height) {
        answer++;
      }
    }
    
    return answer;
  }
}
```

<mark>중복된 숫자 개수</mark>
```
import java.util.*;

class Solution {
  public int solution(int[] array, int n) {
    int answer = 0;
    
    Arrays.sort(array);
    
    for (int v : array) {
      if (v > n) {
        break;
      }
      
      if (v == n) {
        answer++;
      }
    }
    
    return answer;
  }
}
```