---
title: "Java 코딩테스트 필수 문법 및 자료구조/알고리즘 정리"
excerpt: ""

categories:
  - 파이썬 / 코딩테스트
tags:
  - []

permalink: /python/2024-05-01-1

toc: true
toc_sticky: true

date: 2024-05-01
last_modified_at: 2024-05-01
---

## 코딩테스트 문제 푸는 방법

1. 문제와 제약사항을 분석하며, 코드 설계를 주석으로 작성합니다.
2. 입력 값의 크기가 10의 8승(1억) 이상이면, 시간복잡도 O(n) 이하 자료구조/알고리즘을 선택합니다.<br>
제한시간 1초 문제에 시간복잡도 O(n²) 자료구조/알고리즘을 사용하려면 입력 값이 5,000 이내여야 합니다.<br>
컴퓨터가 초당 연산할 수 있는 최대 횟수가 1억이기 때문입니다.
4. 코드 설계에 따라 구현하고, 테스트 케이스를 통과할 수 있게 합니다.

### 핵심 키워드로 자료구조/알고리즘 선택
작성예정

### Java 코드 실행시간 게산 방법
```
long start = System.currentTimeMillis();

// 실행시간을 계산할 코드 작성

long end = System.currentTimeMillis();

System.out.println(((end - start) / 1000.0) + "초");
```

---

## Java 문법 및 자료구조

<mark>변수 타입</mark>
<table class="table_2_left">
  <tbody>
    <tr>
      <td>프리미티브 타입</td>
      <td>int, long, float, double, char 등</td>
    </tr>
    <tr>
      <td>레퍼런스 타입</td>
      <td>Integer, Long, Float, Double, Character 등</td>
    </tr>
  </tbody>
</table>
참조형 변수인 레퍼런스 타입은 메모리에 직접 값을 저장하는 프리미티브 타입보다 연산 속도가 느리고,  
컬렉션 프레임워크에 저장할 때 주로 사용됩니다.

### 정수형
```
// 더하기
a + b

// 빼기
a - b

// 곱하기
a * b

// 나누기 (소수점 버림)
a / b

// 나눈 나머지 반환 (소수점 버림)
a % b

// a가 b보다 크면 양수 반환
Integer.compare(a, b);
```

### 문자열 수정
Java에서 String은 값을 변경할 수 없는 객체이므로, 기존 객체를 수정하지 않고 새로운 객체를 반환합니다.

<mark>String 사용법</mark>
```
// 비효율적 문자열 더하기 (값 복사 n * 값 저장 n) : O(n²)
String str = "문자열";
System.out.println(System.identityHashCode(str)); // 객체 해시코드 : 1808253012
str += "문자열2";
System.out.println(System.identityHashCode(str)); // 객체 해시코드 : 589431969 (다른 객체가 됨)

// 효율적 문자열 삭제
str = str.replace("1", ""); // 문자열에서 "1" 전체 삭제

// 0번째부터 5번째 앞까지 문자열 추출
str.substring(0, 5);

// 문자열을 char 배열로 변환하고 각 문자 반복
for (char c : str.toCharArray()) { }

// 문자열을 정수로 변환
int i = Integer.parseInt("문자열");

// sb 문자열을 Long으로 변환
long l = Long.parseLong(sb.toString());
```

<mark>StringBuilder 사용법</mark>
```
// StringBuilder를 이용한 효율적 문자열 더하기
StringBuilder sb = new StringBuilder();
sb.append("문자열");
sb.append("문자열2");

// 3번째 문자열 삭제
sb.deleteCharAt(3);

// 1번째 인덱스에 문자열 추가
sb.insert(1, "문자열");
```
멀티스레드 환경에서는 Thread-Safe 한 StringBuffer를 사용해야 합니다.

### 배열 (Array)
생성한 배열 크기를 변경할 수 없으므로, 저장할 데이터의 개수를 알 수 있을 때 사용합니다.  
보통 1차원 배열은 1,000만개, 2차원 배열은 3,000 * 3,000 크기를 넘으면 배열 할당이 실패될 수 있습니다.

<mark>1차원 배열 사용법</mark>
```
import java.util.Arrays;

public class Solution {
  public static void main(String[] args) {

    // 배열 생성
    int[] arr = { 1, 2, 3, 4, 5 };
    int[] arr = new int[] { 1, 3, 5, 7, 9 };
    int[] arr = new int[5]; // { 0, 0, 0, 0, 0 }

    // 0번째 원소 값을 1으로 변경 : O(1)
    arr[0] = 1;

    // 3번째 값 접근 : O(1)
    System.out.println(arr[2]);

    // 배열 전체 출력 : O(n)
    System.out.println(Arrays.toString(arr));
    // [1, 2, 3, 4, 5]

    // 배열 데이터 개수
    arr.length;

    // 배열 오름차순 정렬 : O(nlogn)
    Arrays.sort(arr);

    // 배열의 인덱스 1부터 4까지의 요소를 정렬
    Arrays.sort(arr, 1, 5);
    
    // 배열 복제
    int[] clone = arr.clone();

    // 배열 자르기 (i번째부터 j번째까지)
    int[] slicedArr = Arrays.copyOfRange(arr, i-1, j);
    
    // Integer 배열을 int 배열로 변환
    int[] arr = Arrays.stream(Integer배열).mapToInt(Integer::intValue).toArray();
  }
}
```

<mark>2차원 배열 사용법</mark>
```
import java.util.Arrays;

public class Solution {
  public static void main(String[] args) {

    // 2차원 배열 생성
    int[][] arr = { {1,2,3}, {4,5,6} }; // 2행 3열

    // 1번째 배열의 2번째 값 변경
    arr[1][2] = 7;

    // 2차원 배열 값 출력
    System.out.println(arr[1][2]);

    2차원 배열 전체 출력
    System.out.println(Arrays.deepToString(arr));
  }
}
```
배열은 차원과는 무관하게, 메모리에 연속 할당됩니다.

### 리스트 (ArrayList)
가변 크기이므로 데이터를 자유롭게 삽입/삭제할 수 있습니다.  
데이터 접근은 시간복잡도가 O(1)으로 빠르고, 중간 데이터 삽입/삭제는 O(n)으로 느립니다.
```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

// import java.util.*; 으로 한번에 가능

public class Solution {
  public static void main(String[] args) {

    // 리스트 객체 생성
    ArrayList<Integer> list = new ArrayList<>();
    ArrayList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

    // 배열을 리스트로 변환
    ArrayList<Integer> list = new ArrayList<>(Arrays.asList(배열));

    // 리스트를 배열로 변환
    int[] arr = list.stream().mapToInt(Integer::intValue).toArray();

    // 해시맵의 값으로 리스트 객체 생성
    ArrayList<Integer> list = new ArrayList<>(map.values());

    // 리스트 마지막에 값 추가 : O(1)
    list.add(값);

    // 리스트 첫번째에 값 추가 : O(n)
    list.add(0, 값);

    // 리스트의 0번째 원소 출력
    System.out.println(list.get(0));

    // 리스트 마지막 원소 삭제 : O(1)
    list.remove(list.size() -1);

    // 리스트 첫번째 원소 삭제 : O(n)
    list.remove(0);

    // 리스트 전체 출력
    System.out.println(list);

    // 리스트 복사
    ArrayList<Integer> list2 = new ArrayList<>(list);

    // 리스트 데이터 개수
    list.size();

    // 리스트가 비어있는지 확인
    if (list.isEmpty()) { }

    // 리스트 오름차순 정렬 : O(nlogn)
    Collections.sort(list);

    // 리스트 내림차순 정렬 : O(nlogn)
    Collections.sort(list, Collections.reverseOrder());

    // 리스트의 인덱스 1부터 5 앞까지의 요소를 정렬
    Collections.sort(list.subList(1, 5));
  }
}
```

### 스택 (Stack)
먼저 입력한 데이터를 나중에 꺼내는 선입후출(FILO) 자료구조입니다.  
최근에 삽입한 데이터를 대상으로 연산할 때 사용하면 좋습니다.
```
// 스택 객체 생성
Stack<Integer> stack = new Stack<>();

// 스택에 데이터 삽입 : O(1)
stack.push(1);

// 스택에서 마지막 데이터를 제거하지 않고 반환
stack.peek();

// 스택이 비어있는지 확인 (스택이 비어있을 때 pop 하면 EmptyStackException 발생)
if (stack.isEmpty()) {
  // 스택에서 마지막 데이터 제거 후 반환 : O(1)
  stack.pop();
};

// 스택 데이터 개수
stack.size();

// 스택의 모든 요소를 문자열로 더하기 : O(n)
StringBuilder sb = new StringBuilder();
while (!stack.isEmpty()) {
  sb.append(stack.pop());
}
```
Stack 보다 메모리 효율적이고 성능이 좋은 ArrayDeque 사용이 권장됩니다.

### 큐 (Queue)
먼저 입력한 데이터를 먼저 꺼내는 선입선출(FIFO) 자료구조입니다.  
작업 대기열이나 이벤트 처리에 사용하면 좋습니다.  
Queue 인터페이스에 ArrayDeque 또는 LinkedList를 구현체로 사용하면 됩니다.
```
// Queue를 구현한 LinkedList 객체 생성 (큐 생성)
Queue<Integer> queue = new LinkedList<>();

// 큐에 데이터 추가
queue.offer(1);

// 큐의 맨 앞 데이터를 제거하지 않고 반환
queue.peek();

// 큐의 맨 앞 데이터를 제거 후 반환
queue.poll();

// 큐가 비어있는지 확인
queue.isEmpty();
```
Queue보다 메모리 효율적이고 빠른 연산이 가능한 ArrayDeque 사용이 권장됩니다.

### 데크 (ArrayDeque) ★
스택/큐와 달리, 양쪽에서 데이터를 삽입/삭제할 수 있는 자료구조입니다.  
ArrayDeque를 응용하여 스택/큐를 구현하면 좋습니다.
<br>

<mark>ArrayDeque로 스택 구현</mark>
```
// Deque를 구현한 ArrayDeque 객체 생성 (스택 생성)
Deque<Integer> stack = new ArrayDeque<>();

// 스택에 데이터 추가
stack.addLast(1);

// 스택의 마지막 데이터를 제거하지 않고 반환
stack.peekLast();

// 스택의 마지막 데이터를 제거 후 반환
stack.pollLast(1);

// 스택이 비어있는지 확인
stack.isEmpty();

// 스택 전체 삭제
stack.clear();
```
addLast(), pollLast()만 사용하여 구현합니다.

<mark>ArrayDeque로 큐 구현</mark>
```
// Queue를 구현한 ArrrayDeque 객체 생성 (큐 생성)
Queue<Integer> queue = new ArrayDeque<>();

// 큐에 데이터 추가
queue.addLast(1); // 또는 queue.add(1);

// 큐의 맨 앞 데이터를 제거하지 않고 반환
queue.peekFirst(); // 또는 queue.peek();

// 큐의 맨 앞 데이터를 제거 후 반환
queue.pollFirst(); // 또는 queue.poll();

// 큐가 비어있는지 확인
queue.isEmpty();

// 큐 전체 삭제
queue.clear();
```
addLast(), pollFirst()만 사용하여 구현합니다.

### 우선순위 큐 (PriorityQueue)
우선순위가 높은 데이터를 먼저 poll하는 자료구조입니다.  
일반적으로 완전 이진 트리로 구성된 힙 자료구조를 사용하여 구현합니다.  
작업 스케줄링, 응급실 대기열, 네트워크 트래픽 제어, 교통 네트워크 최적화 등에 활용됩니다.
```
// 오름차순 정렬하는 우선순위 큐 객체 생성 (기본적으로 Min Heap이라서 작은 값부터 나옵니다.)
PriorityQueue<Integer> pq = new PriorityQueue<>();

// 내림차순 정렬하는 우선순위 큐 객체 생성
PriorityQueue<String> pq = new PriorityQueue<>(Collections.reverseOrder());

// 노드의 cost 값에 따라 오름차순 정렬하는 우선순위 큐 객체 생성
PriorityQueue<String> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1.cost, o2.cost));

// 컬렉션의 모든 데이터를 담은 우선순위 큐 객체 생성
PriorityQueue<String> pq = new PriorityQueue<>(list);

// 컬렉션의 모든 데이터를 우선순위 큐 객체에 삽입 : O(n)
pq.addAll(list);

// 값을 우선순위 큐에 삽입 : O(logn)
pq.add(값);

// 우선순위가 높은 원소 제거 후 반환 : O(logn)
pq.poll();

// 우선순위 큐 전체 출력 (우선순위 큐는 꺼내면서 정렬하므로, 삽입 후 pq는 정렬된 상태가 아닙니다.)
System.out.println(pq);
```

### 해시 (Hash)
키를 해시 함수를 통해 변환한 해시 값 인덱스에 값을 저장해서 검색이 빠른 자료구조입니다.  
키로 검색하면 값을 O(1)으로 찾을 수 있으며, 키-값 데이터를 버킷이라고 합니다.  
비밀번호, DB 인덱싱, 블록체인 등 검색 횟수가 많거나 보안이 필요한 경우 사용합니다.

<mark>HashMap</mark>
```
// 해시맵 객체 생성 (HashTable 클래스는 잘 사용되지 않습니다.)
HashMap<String, Integer> map = new HashMap<>();

// 해시맵 값 삽입 및 수정 (같은 키 값으로 넣으면, 기존에 저장된 값이 수정됩니다.)
map.put("키", 값);

// 해시맵에서 키-값 삭제
map.remove("키");

// 해시맵에서 모든 데이터 삭제
map.clear();

// 해시맵에 데이터가 있는지 확인
map.isEmpty();

// 해시맵 데이터 개수 확인
map.size();

// 해시맵에 키가 있는지 확인
if (map.containsKey("키")) {
  // 해시맵 값 출력
  System.out.println(map.get("키"));
}

// 값이 없으면 기본값 출력
map.getOrDefault("키", 기본값);

// 해시맵에 값이 있는지 확인
if (map.containsValue(값)) {
  System.out.println("값이 존재합니다."));
}

// 해시맵 전체 출력
System.out.println(map);

// 해시맵 키셋 순회하며 출력
Set<String> keySet = map.keySet();
for (String key : keySet) {
    System.out.println(key);
}
```

### 집합 (Set)
순서와 중복이 없는 원소들을 갖는 자료구조입니다.  

<mark>HashSet</mark> : 해시테이블 기반으로 구현 되어있습니다.
```
// 중복을 허용하지 않는 Hash 집합(Set) 생성
HashSet<Integer> hashSet = new HashSet<>();

for (int i : arr) {
  // target에서 현재 원소를 뺀 값이 해시셋에 있는지 확인
  if (hashSet.contains(target - i)) {
    return true;
  }

  // 해시셋에 현재 값 저장
  hashSet.add(i);
}

// 해시셋 데이터 개수 확인
hashSet.size();
```
배열에서 두 수의 합이 특정한 값이 되는지 O(1)으로 확인할 수 있습니다.

<mark>TreeSet</mark> : 이진 검색 트리 기반으로 구현되어 있습니다.
```
import java.util.Collections;
import java.util.TreeSet;

public class Solution {
  private static int[] solution(int[] arr) {
    // 중복값 제거, 내림차순 정렬
    TreeSet<Integer> set = new TreeSet<>(Collections.reverseOrder());
    for (int num : arr) {
      set.add(num);
    }

    // int형 배열에 담아서 반환
    int[] result = new int[set.size()];
    for (int i = 0; i < result.length; i++) {
      result[i] = set.pollFirst();
    }
    return result;
  }
}
```
TreeSet을 사용하면 정렬과 중복 제거를 O(NlogN)으로 구현할 수 있습니다.

### 트리 (Tree)
계층 구조 데이터를 저장하고 표현하기 위한 자료구조입니다.  
인공지능의 의사 결정 트리, 자동 완성 기능, 데이터베이스(B-트리, B+트리) 등에 사용합니다.  
이진 트리는 모든 노드의 최대 차수(자식 노드 수)가 2인 트리입니다.

### 그래프 (Graph)
노드와 방향/무방향 간선을 이용한 비선형 자료구조입니다.  
간선에는 가중치가 존재할 수 있습니다.

---

## 알고리즘 개념 정리

### 깊이 우선 탐색 (DFS) ★
그래프의 시작 노드부터 간선을 따라 가장 깊은 노드까지 이동하고,  
이전에 방문한 노드로 되돌아오며 연결된 노드 중 방문하지 않은 노드를 다시 최대 깊이까지 방문합니다.  
스택에 다음 방문할 노드를 push 후 pop 하여 방문 처리 하거나, 재귀를 사용하여 DFS를 구현할 수 있습니다.  
최단 경로를 찾는 문제가 아니면 깊이 우선 탐색을 우선 고려해보는 것이 좋습니다.

<mark>스택으로 DFS 구현</mark>
1. 스택에 시작 노드를 push (추가)
2. 스택 반복 시작
3. if 스택이 비어있다면 탐색 종료
4. 스택에 최근 push 한 노드를 pop하고 방문 여부 확인 후 방문 처리
5. 방문한 노드와 인접한 모든 노드를 확인 후 아직 방문하지 않은 노드를 스택에 push <br>
스택은 선입후출 구조이므로, 방문 순서의 역순으로 노드를 push해야 합니다.

### 너비 우선 탐색 (BFS) ★
그래프의 시작 노드부터 차수가 가장 가까운 노드들을 우선하여 방문하는 알고리즘입니다.  
큐에 지금 방문할 노드를 add 하여 방문 처리 하면서 구현할 수 있습니다.  
최단 경로를 찾는 미로찾기 문제, 네트워크 분석 문제에서 사용할 수 있습니다.

<mark>큐로 BFS 구현</mark>
1. 큐에 그래프의 시작 노드 add (추가)
2. 큐 반복 시작
3. if 큐가 비어있다면 탐색 종료
4. 큐에서 노드를 하나씩 꺼내어 poll (삭제)
5. poll한 노드와 인접한 노드 중 방문하지 않은 노드를 큐에 추가하며 방문 처리

### 다익스트라
가중치가 있는 그래프의 최단 경로를 구하는 문제에 사용되는 알고리즘입니다.  
현재 노드에서 방문할 수 있는 아직 방문하지 않은 노드 중에서 최소 비용이 가장 적은 노드를 선택합니다.  
우선순위 큐로 구현할 수 있으며, 음의 가중치가 있는 그래프에서는 제대로 동작하지 않습니다.

### 백트래킹
모든 경우의 수를 탐색하는 완전탐색과 달리, 답이 될 가능성이 없는 노드에서는 탐색을 배제하고 되돌아가는 알고리즘입니다.  
백트래킹은 주로 DFS를 기반으로 하며, 재귀적으로 구현되고 완전탐색보다 효율적입니다.

### 정렬
정의된 순서로 데이터를 나열하는 것입니다.

<mark>람다 함수로 정렬</mark>  
람다식은 한 번만 실행할 목적으로 코드를 간결하게 표현하는 익명 함수입니다.
```
// 배열에 저장된 객체의 int 변수 값을 받아서 비교 후 오름차순 정렬합니다.
Arrays.sort(배열, (객체명 o1, 객체명 o2) -> Integer.compare(o1.int변수명, o2.int변수명));
// o1 > o2면 1을 반환하여 서로의 위치를 변경합니다.
```

### 시뮬레이션
문제에 주어진 상황을 완벽하게 이해하고 코드로 구현하는 과정입니다.  
다른 알고리즘처럼 일반화한 방법으로 문제를 풀 수 없습니다.  
배열 회전하기, 전치 행렬 만들기, 달팽이 수열 만들기 등의 문제가 있습니다.

### 동적계획법 (DP)
전체 문제를 작은 부분 문제들로 나누어 해결한 것으로 해결하는 알고리즘입니다.  
동일한 작은 문제가 반복되고, 문제들의 결과를 재활용하여 해결이 가능한 경우 사용합니다.  
단순히 작은 문제를 조합해서 큰 문제를 해결하는 분할 정복과는 다릅니다.

<mark>재귀를 활용하여 DP 구현</mark>
1. 종료 조건을 설정합니다.
2. 재귀로 반복할 수 있는 점화식을 세웁니다.
3. 작은 문제의 결과를 메모이제이션 기법으로 저장하여 중복 계산을 피합니다.

### 그리디 (Greedy)
문제 해결 과정에서 눈 앞에 보이는 최선의 선택만을 하며, 선택은 번복하지 않는 알고리즘입니다.  
각 선택이 부분해를 구하는 과정 및 최적해를 구하는 과정과 일치하고,  
전체 문제 해결에 영향을 주지 않을 때 사용해야 합니다.

### 이진탐색
정렬된 배열에서 특정 값을 찾을 때, 중간값을 기준으로 탐색 범위를 줄이는 알고리즘입니다.
