---
title: "DB 설계 시 참고사항 / 테이블 및 인덱스 설계 시 참고 (작성중)"
excerpt: ""

categories:
  - 기획 / 설계 / DB
tags:
  - []

permalink: /plan-design-db/2022-05-26-1

toc: true
toc_sticky: true
 
date: 2022-05-26
last_modified_at: 2022-05-26
---

## DB 테이블 설계

### 테이블 명명규칙
- snake_case 사용하여 소문자로 작성
- tb_ 등 prefix, suffix는 사용은 옛날 방식이므로 권장X
- 기존 테이블 명명 규칙이 있다면 따르기 (다중 규칙X)

### 컬럼 명명규칙
- snake_case 사용하여 소문자로 작성
- 같은 테이블명 prefix는 가급적 생략하여 간결하게 작성

<mark>변수명 짓기 사이트</mark>  
<https://www.curioustore.com>{: target="_blank"}  
변수명 짓기 사이트 이용 시 시간 단축 가능합니다.

### 테이블 설계 시 추가할 만한 컬럼
PK 외 필수 컬럼은 없습니다. 테이블 성격이나 기능에 맞게 추가하면 됩니다.
<table class="table_4_left">
  <thead>
    <tr>
      <th>컬럼명</th>
      <th>Data Type</th>
      <th>제약조건</th>
      <th>Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>int</td>
      <td>AUTO_INCREMENT</td>
      <td>PK (seq)</td>
    </tr>
    <tr>
      <td>테이블명_id</td>
      <td>int</td>
      <td> </td>
      <td>FK (타 테이블 Key)</td>
    </tr>
    <tr>
      <td>_cd</td>
      <td>varchar</td>
      <td>DEFAULT ''</td>
      <td>코드명</td>
    </tr>
    <tr>
      <td>_name</td>
      <td>nvarchar</td>
      <td>DEFAULT ''</td>
      <td>이름 (한글명)</td>
    </tr>
    <tr>
      <td>content</td>
      <td>mediumtext</td>
      <td>DEFAULT ''</td>
      <td>본문 (text &lt; mediumtext &lt; longtext)</td>
    </tr>
    <tr>
      <td>sort</td>
      <td>int</td>
      <td>DEFAULT 1</td>
      <td>정렬순서 (정렬 필요 시 추가)</td>
    </tr>
    <tr>
      <td>_cnt</td>
      <td>int</td>
      <td>DEFAULT 0</td>
      <td>수 (SUM, 통계)</td>
    </tr>
    <tr>
      <td>_yn</td>
      <td>char(1)</td>
      <td>DEFAULT 'Y or N'</td>
      <td>2가지로 나뉠 수 있는 상태값 (Y, N)</td>
    </tr>
    <tr>
      <td>_status</td>
      <td>int</td>
      <td>DEFAULT 0</td>
      <td>3가지 이상으로 나뉠 수 있는 상태값</td>
    </tr>
    <tr>
      <td>_type</td>
      <td>varchar</td>
      <td>DEFAULT '기본타입'</td>
      <td>타입, 유형</td>
    </tr>
    <tr>
      <td>file_path</td>
      <td>varchar(255)</td>
      <td>DEFAULT ''</td>
      <td>파일경로/파일명</td>
    </tr>
    <tr>
      <td>file_org_name</td>
      <td>nvarchar(50)</td>
      <td>DEFAULT ''</td>
      <td>원본파일명</td>
    </tr>
    <tr>
      <td>create_date</td>
      <td>datetime</td>
      <td>DEFAULT NOW()</td>
      <td>등록일시 (생성 이력관리 필요 시)</td>
    </tr>
    <tr>
      <td>create_user_id</td>
      <td>varchar</td>
      <td>DEFAULT ''</td>
      <td>등록자 (생성 이력관리 필요 시)</td>
    </tr>
    <tr>
      <td>update_date</td>
      <td>datetime</td>
      <td>DEFAULT NOW()</td>
      <td>수정일시 (수정 이력관리 필요 시)</td>
    </tr>
    <tr>
      <td>update_user_id</td>
      <td>varchar</td>
      <td>DEFAULT ''</td>
      <td>수정자 (수정 이력관리 필요 시)</td>
    </tr>
    <tr>
      <td>use_yn</td>
      <td>char(1)</td>
      <td>DEFAULT 'Y'</td>
      <td>사용여부 (데이터를 화면에 노출시킬 지 여부)</td>
    </tr>
    <tr>
      <td>last_use_date</td>
      <td>datetime</td>
      <td>DERAULT NOW()</td>
      <td>최근사용일 (마지막 사용일)</td>
    </tr>
    <tr>
      <td>delete_yn</td>
      <td>char(1)</td>
      <td>DEFAULT 'N'</td>
      <td>삭제여부 (삭제 기능 존재 시 추가)</td>
    </tr>
  </tbody>
</table>

### PK 설계 순서
<strong>1. </strong>유니크해야 하는 테이블이고 PK가 꼭 필요한지 판단  
<strong>2. </strong>자주 조인하기 번거로운 복합키 지정이 꼭 필요하지 않다면 단일키(Auto_increment) 사용 고려

### 외래키(FK) 논리적(ERD)으로 그리는데 물리적(DB)으로 안거는 이유
- 대량의 쿼리 시 성능이 느려질 수 있습니다.
- 서브 테이블에 테스트 데이터를 만들기 불편합니다.
- 테이블 구조 변경 시 제약사항 발생합니다.

### INT 등 다른 타입도 NVARCHAR로 설계하는 이유
형변환에 신경쓰지 않고 데이터 유연성을 높이기 위해서입니다.

---

## DB 인덱스 및 성능 튜닝

### 인덱스 설계 시 참고
테이블 설계 시에는 PK만 제대로 잡아두고, 인덱스는 데이터가 많이 쌓여서 쿼리가 느려졌을 때 조정해도 됩니다.

인덱스(색인) 걸면 인덱스 테이블을 정렬하며 관리하니 Insert, Update, Delete 성능이 안좋고 Select 성능만 좋아집니다.  
Update, Delete 없고 Insert 자주, Select 가끔 발생하는 로그, 통계 테이블에는 PK가 필요 없는 경우가 많습니다.

PK를 걸면 PK 컬럼 순서대로 PRIMARY 인덱스 (복합 인덱스) 자동 생성됩니다.  
PK 없는 대용량 데이터에서 검색이 일어나야 한다면, 검색 조건 컬럼들에 인덱스를 걸어주면 됩니다.

복합 인덱스는 검색 조건에 들어갈 컬럼, 경우의 수가 많은 컬럼 (분포도 높은 컬럼) 순으로 설계하는 것이 좋습니다.

복합 인덱스 첫번째 컬럼이 검색조건에 없다면 나머지 검색조건 컬럼들을 각각 단일 인덱스로 잡아줘야 인덱스를 탑니다.  
PK가 A, B, C인데 WHERE A = ''가 있다면 나머지 B, C 검색조건도 인덱스를 타니 단일 인덱스가 없어도 됩니다.

Select 시 검색조건 컬럼 뿐 아니라 Group by 컬럼도 인덱싱 되어있으면 조회 속도가 빠릅니다.

### DB 검색 성능 튜닝
DBMS는 Select 시 인덱스 테이블에서 검색(거의 10번 이내) 후 조건에 맞는 데이터 키를 테이블에서 검색하여 보여줍니다.

검색 속도가 낮다면 인덱스를 안타고 풀스캔 하고 있는지 확인 후 쿼리나 인덱스 변경으로 튜닝할 수 있습니다.

운영 중에 인덱스를 생성하면 락이 걸리므로 운영 시간 외에 변경해야 합니다.

### 테이블 분할 설계
상세 데이터 중 용량이 큰 컬럼이 있다면 단순 목록 조회 시 부하를 줄이기 위해 상세 테이블을 따로 만들기도 합니다.

용량이 작은 컬럼들만 있다면 하나의 테이블로 만들어도 충분합니다.
